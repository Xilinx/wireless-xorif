<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xilinx O-RAN Radio Unit: API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="html_custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign">
   <div id="projectname">Xilinx O-RAN Radio Unit
   </div>
   <div id="projectbrief">Software Driver Library O-RAN Radio Interface (libxorif)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">API</div></div>
</div><!--header-->
<div class="contents">

<p>"C" API for the Xilinx ORAN Channel Processor (libxocp)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxocp__caps.html">xocp_caps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for supported capabilities.  <a href="structxocp__caps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxocp__cc__data.html">xocp_cc_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for component carrier configuration used in <a class="el" href="group__libxocp.html#ga91cb69c970d87cb2de7a465935151a93" title="Set the component carrier configuration.">xocp_set_cc_cfg</a>, etc.  <a href="structxocp__cc__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxocp__antenna__data.html">xocp_antenna_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for antenna configuration data used in <a class="el" href="group__libxocp.html#ga5ee188ec91e4704e86f24d134f84ac61" title="Set the antenna configuration.">xocp_set_antenna_cfg</a>, etc.  <a href="structxocp__antenna__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxocp__trigger__data.html">xocp_trigger_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for trigger configuration.  <a href="structxocp__trigger__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxocp__triggers.html">xocp_triggers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for all triggers used in <a class="el" href="group__libxocp.html#ga6faf33afeb951c812a95d195a5d1fbe5" title="Set the HW trigger configuration for DL/UL &quot;update&quot;.">xocp_set_trigger_cfg</a>, etc.  <a href="structxocp__triggers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxorif__caps.html">xorif_caps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for supported capabilities.  <a href="structxorif__caps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxorif__cc__config.html">xorif_cc_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the requested component carrier configuration.  <a href="structxorif__cc__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxorif__cc__alloc.html">xorif_cc_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the actual allocated component carrier configuration.  <a href="structxorif__cc__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxorif__fhi__eth__stats.html">xorif_fhi_eth_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for Front-Haul Interface Ethernet statistic information.  <a href="structxorif__fhi__eth__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxorif__system__constants.html">xorif_system_constants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for Front-Haul specific system "constants".  <a href="structxorif__system__constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxorif__stall__monitor.html">xorif_stall_monitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for "stall-detection" results.  <a href="structxorif__stall__monitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga682b7a43e80776571d78c8588b9983ff" id="r_ga682b7a43e80776571d78c8588b9983ff"><td class="memItemLeft" align="right" valign="top"><a id="ga682b7a43e80776571d78c8588b9983ff" name="ga682b7a43e80776571d78c8588b9983ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XOCP_NUM_INSTANCES</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga682b7a43e80776571d78c8588b9983ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of driver instances. <br /></td></tr>
<tr class="separator:ga682b7a43e80776571d78c8588b9983ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151cc3771661727a0bfcaef9fc8aa0c5" id="r_ga151cc3771661727a0bfcaef9fc8aa0c5"><td class="memItemLeft" align="right" valign="top"><a id="ga151cc3771661727a0bfcaef9fc8aa0c5" name="ga151cc3771661727a0bfcaef9fc8aa0c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XOCP_MAX_NUM_CC</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga151cc3771661727a0bfcaef9fc8aa0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of component carriers supported. <br /></td></tr>
<tr class="separator:ga151cc3771661727a0bfcaef9fc8aa0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675657e20d15f73a68e2d6f87fdb02d0" id="r_ga675657e20d15f73a68e2d6f87fdb02d0"><td class="memItemLeft" align="right" valign="top"><a id="ga675657e20d15f73a68e2d6f87fdb02d0" name="ga675657e20d15f73a68e2d6f87fdb02d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XOCP_MAX_ANTENNA</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga675657e20d15f73a68e2d6f87fdb02d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of antennas supported by SW. <br /></td></tr>
<tr class="separator:ga675657e20d15f73a68e2d6f87fdb02d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa2aee8cec3c52814f6b30da8f44871b0" id="r_gaa2aee8cec3c52814f6b30da8f44871b0"><td class="memItemLeft" align="right" valign="top"><a id="gaa2aee8cec3c52814f6b30da8f44871b0" name="gaa2aee8cec3c52814f6b30da8f44871b0"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>xocp_isr_func_t</b>) (uint16_t instance, uint32_t status)</td></tr>
<tr class="memdesc:gaa2aee8cec3c52814f6b30da8f44871b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for event interrupts call-back function. <br /></td></tr>
<tr class="separator:gaa2aee8cec3c52814f6b30da8f44871b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8faee7bbc7441a5fcbfa86e44a838fcf" id="r_ga8faee7bbc7441a5fcbfa86e44a838fcf"><td class="memItemLeft" align="right" valign="top"><a id="ga8faee7bbc7441a5fcbfa86e44a838fcf" name="ga8faee7bbc7441a5fcbfa86e44a838fcf"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>isr_func_t</b>) (uint32_t status)</td></tr>
<tr class="memdesc:ga8faee7bbc7441a5fcbfa86e44a838fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for alarm interrupt call-back function. <br /></td></tr>
<tr class="separator:ga8faee7bbc7441a5fcbfa86e44a838fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf451ae0ea9768ba9266531c370a55c94" id="r_gaf451ae0ea9768ba9266531c370a55c94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf451ae0ea9768ba9266531c370a55c94">xocp_error_codes</a> { <br />
&#160;&#160;<a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a794b4b16c40fdc8eb8c60707dadfe29a">XOCP_OPERATIONAL_ERRORS</a> = -3000
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a1df7c88f34e194938fa608f16590f7cc">XOCP_NULL_POINTER</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a54e7ef62dc8a5d50c5e01b7cc6c6e6d4">XOCP_REGISTER_NOT_FOUND</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94aafaefa566de3ba034b708009c3578be4">XOCP_MEMORY_ALLOCATION_FAIL</a>
, <br />
&#160;&#160;<a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a00e01abfade942c7ae2bb8ce6971d84f">XOCP_TIMEOUT_FAIL</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a663ede6ec196fa468f8ea6c1e7ab6060">XOCP_CONFIGURATION_ERRORS</a> = -2000
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a77e9e16463ab641c00a8912f37d5596b">XOCP_INVALID_CC</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a9e002468b6450125dcb7b47a3960d1e5">XOCP_INVALID_RBS</a>
, <br />
&#160;&#160;<a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94aa35b0cd782754b0a4dc838ab6662c6ff">XOCP_INVALID_NUMEROLOGY</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a4808c3d2a2edc65fb17c033c04b43f65">XOCP_INVALID_ANTENNAS</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94aaf8184e28652afc9cc695d2629de01ab">XOCP_SCHEDULING_ERROR</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94ae7a5dfbc6f6e1a032346b1ffdf322835">XOCP_FRAMEWORK_ERRORS</a> = -1000
, <br />
&#160;&#160;<a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a3690197b67899b7b24d484544893c05c">XOCP_LIBMETAL_ERROR</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a2d323c9201910db34f5e9f1acd3cc94a">XOCP_NO_SUCH_DEVICE</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94adffcd4c49097bfc116c8d60f3f1877de">XOCP_NO_RESOURCES</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a7d343d91e5e2ef27617aa050b3a6f7f9">XOCP_INVALID_INSTANCE</a>
, <br />
&#160;&#160;<a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a7407194a50b20a599938ce060344e4bc">XOCP_INVALID_STATE</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a9c8f4b684f5f945359e9d6688f04ac80">XOCP_OTHER_ERRORS</a> = -500
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94af1c7f4d1634f7a592b60d4537d24dc9f">XOCP_NOT_SUPPORTED</a>
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94afc0ac5ea9864017911e7bbfc0c02569a">XOCP_INVALID_RESULT</a> = -1
, <br />
&#160;&#160;<a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a59302365415c9401277a5c89e2d717dc">XOCP_SUCCESS</a> = 0
, <a class="el" href="#ggaf451ae0ea9768ba9266531c370a55c94a3d2b0813042f04655882f64a9ee0c836">XOCP_FAILURE</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:gaf451ae0ea9768ba9266531c370a55c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for error/status codes.  <a href="#gaf451ae0ea9768ba9266531c370a55c94">More...</a><br /></td></tr>
<tr class="separator:gaf451ae0ea9768ba9266531c370a55c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8be4e9d392425029993a9e8ad95b2be6" id="r_ga8be4e9d392425029993a9e8ad95b2be6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8be4e9d392425029993a9e8ad95b2be6">xocp_events</a> { <br />
&#160;&#160;<a class="el" href="#gga8be4e9d392425029993a9e8ad95b2be6abc22c1565927dfec8392303c3003fddb">XOCP_DL_CC_UPDATE_TRIGGERED</a> = 0x1
, <a class="el" href="#gga8be4e9d392425029993a9e8ad95b2be6af4389c5431a1c67bc749b798c0ed4c62">XOCP_DL_SEQUENCE_ERROR</a> = 0x2
, <a class="el" href="#gga8be4e9d392425029993a9e8ad95b2be6ad48ac96c5eb710be181edcbc4a72ddf5">XOCP_DL_SEQUENCE_TABLE_ERROR</a> = 0x4
, <a class="el" href="#gga8be4e9d392425029993a9e8ad95b2be6a28ee5450c2e063d6354e99a079ea20c7">XOCP_UL_CC_UPDATE_TRIGGERED</a> = 0x100
, <br />
&#160;&#160;<a class="el" href="#gga8be4e9d392425029993a9e8ad95b2be6a35aa4b4942ebdc467144a9242543c864">XOCP_UL_SEQUENCE_ERROR</a> = 0x200
, <a class="el" href="#gga8be4e9d392425029993a9e8ad95b2be6a2a824057e95d8053f1397fcf5f3b184c">XOCP_UL_SEQUENCE_TABLE_ERROR</a> = 0x400
<br />
 }</td></tr>
<tr class="memdesc:ga8be4e9d392425029993a9e8ad95b2be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerations for error/event information.  <a href="#ga8be4e9d392425029993a9e8ad95b2be6">More...</a><br /></td></tr>
<tr class="separator:ga8be4e9d392425029993a9e8ad95b2be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4565d94bfd9eeaa7959e4a06db49d0f" id="r_gad4565d94bfd9eeaa7959e4a06db49d0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4565d94bfd9eeaa7959e4a06db49d0f">xocp_states</a> { <a class="el" href="#ggad4565d94bfd9eeaa7959e4a06db49d0fa02536e433de6b5137abf629c4c4b466f">XOCP_IDLE</a> = 0
, <a class="el" href="#ggad4565d94bfd9eeaa7959e4a06db49d0faf97eab56e7f58517570b71a6541b5cdc">XOCP_RESET</a>
, <a class="el" href="#ggad4565d94bfd9eeaa7959e4a06db49d0fa36439db5df53566cf5730971b6ee1f42">XOCP_READY</a>
, <a class="el" href="#ggad4565d94bfd9eeaa7959e4a06db49d0fa94df60623c029d864ba346bb08980e64">XOCP_OPERATIONAL</a>
 }</td></tr>
<tr class="memdesc:gad4565d94bfd9eeaa7959e4a06db49d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerations for state machine states.  <a href="#gad4565d94bfd9eeaa7959e4a06db49d0f">More...</a><br /></td></tr>
<tr class="separator:gad4565d94bfd9eeaa7959e4a06db49d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a97d2a2455bd1b40ba42a84ddbe2f3f" id="r_ga9a97d2a2455bd1b40ba42a84ddbe2f3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a97d2a2455bd1b40ba42a84ddbe2f3f">xorif_error_codes</a> { <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa25ee8ecd1294a4d25e52c3df60803a17">XORIF_OPERATIONAL_ERRORS</a> = -3000
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fab1d76613a67b8b15db924f08bd127e4c">XORIF_NULL_POINTER</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fac1b123cc4c3536879c23cb11921ed9d0">XORIF_REGISTER_NOT_FOUND</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3faeda3aba2a8984c7eec1eefa7ff9c717b">XORIF_MEMORY_ALLOCATION_FAIL</a>
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa078386ac24484cbf549961e7a793febc">XORIF_TIMEOUT_FAIL</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa2003ba5fea3e33e16b988ed0a86289d0">XORIF_CONFIGURATION_ERRORS</a> = -2000
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3facda33b30a8f841b3fcbc3fe8c752eaa9">XORIF_INVALID_CC</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa1a73cbf2d1f7292b849f9da3726a0313">XORIF_INVALID_SS</a>
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa09ee5e8b650631ea5acb0d6aca182bd9">XORIF_INVALID_RBS</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa451fc990b012558a4b2d8028c781a7dd">XORIF_INVALID_CONFIG</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa4f91e05f7c3f04097efd384ebe1355b0">XORIF_NUMEROLOGY_NOT_SUPPORTED</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa5a2dddf89e5e2a94e6335821d3329384">XORIF_COMP_MODE_NOT_SUPPORTED</a>
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa1faea537523540ff11fc8bfe9223f320">XORIF_FRONT_HAUL_ERRORS</a> = -1500
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa29e36b3ba768c321b68f719f3398a6ba">XORIF_MAX_CTRL_SYM_EXCEEDED</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa08089c14b12e08ce6ce89c4837ba94b5">XORIF_MAX_DATA_SYM_EXCEEDED</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa3012c11d14676ad9fbee5dea0a63e590">XORIF_BUFFER_SPACE_EXCEEDED</a>
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa5d8be60fc908dae826f288a33c72959f">XORIF_INVALID_ETH_PORT</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3faefb2e12b88492d80d7edab5897587ccc">XORIF_INVALID_EAXC_ID</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa31de86d2f8e0f17527baa020a3daff49">XORIF_INVALID_RU_PORT_MAPPING</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa3bdbf375732f3687ee6924b71bcde20a">XORIF_BEAMFORMER_ERRORS</a> = -1400
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa831f15721b2160abbf5cc4fe7c719e71">XORIF_SCHEDULE_TABLE_EXCEEDED</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa436e1c153c12de5c40bd47e116a17413">XORIF_SCHEDULING_ERROR</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa8fdc834fd2e4fe38a2f8a9459d39c296">XORIF_INVALID_AG</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa2b213a6afb5f585bc912e78955668cee">XORIF_INVALID_DFE</a>
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa774af89ce327da0f5bb3dad6d0d8f048">XORIF_FRAMEWORK_ERRORS</a> = -1000
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa4714fa10d010ea3a706076deba21addc">XORIF_LIBMETAL_ERROR</a>
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa58d26412e9ade9963d87f109cc124392">XORIF_OTHER_ERRORS</a> = -500
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fab68e276251beec0446da47d72b2f490a">XORIF_NOT_SUPPORTED</a>
, <br />
&#160;&#160;<a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3faf431f4841dcd33bca7a22bf73f2e1376">XORIF_INVALID_RESULT</a> = -1
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa64437c7c5e97f4efece41f66478232d1">XORIF_SUCCESS</a> = 0
, <a class="el" href="#gga9a97d2a2455bd1b40ba42a84ddbe2f3fa9a03a40b03b36e83d8ebdc2a08ef6df4">XORIF_FAILURE</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:ga9a97d2a2455bd1b40ba42a84ddbe2f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for error/status codes.  <a href="#ga9a97d2a2455bd1b40ba42a84ddbe2f3f">More...</a><br /></td></tr>
<tr class="separator:ga9a97d2a2455bd1b40ba42a84ddbe2f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26436fd9ffeac8fb09128b81b60f347b" id="r_ga26436fd9ffeac8fb09128b81b60f347b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a> { <br />
&#160;&#160;<a class="el" href="#gga26436fd9ffeac8fb09128b81b60f347ba51d9d0080c8e5d3e3b817eed725a6c84">IQ_COMP_NONE</a> = 0
, <a class="el" href="#gga26436fd9ffeac8fb09128b81b60f347bad4753ac77b5aff45dc89f1f8e2559c26">IQ_COMP_BLOCK_FP</a>
, <a class="el" href="#gga26436fd9ffeac8fb09128b81b60f347ba298523fae234039bd2d8cf2c79b45632">IQ_COMP_BLOCK_SCALE</a>
, <a class="el" href="#gga26436fd9ffeac8fb09128b81b60f347ba92efb1627370176f940e21b4c22007af">IQ_COMP_U_LAW</a>
, <br />
&#160;&#160;<a class="el" href="#gga26436fd9ffeac8fb09128b81b60f347bad1f07bfe78168c2b76d38bddfe4269e5">IQ_COMP_MODULATION</a>
<br />
 }</td></tr>
<tr class="memdesc:ga26436fd9ffeac8fb09128b81b60f347b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for IQ compression modes (ORAN values).  <a href="#ga26436fd9ffeac8fb09128b81b60f347b">More...</a><br /></td></tr>
<tr class="separator:ga26436fd9ffeac8fb09128b81b60f347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42ef3891485579391376bda5ac38175" id="r_gac42ef3891485579391376bda5ac38175"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac42ef3891485579391376bda5ac38175">xorif_iq_comp_flags</a> { <br />
&#160;&#160;<a class="el" href="#ggac42ef3891485579391376bda5ac38175aeb5d9d01ac3e50861238e3a8ee824a00">IQ_COMP_NONE_SUPPORT</a> = 0x01
, <a class="el" href="#ggac42ef3891485579391376bda5ac38175ac85d0a5799f04376791f658b4e181493">IQ_COMP_BLOCK_FP_SUPPORT</a> = 0x02
, <a class="el" href="#ggac42ef3891485579391376bda5ac38175aca4fb10dbe99a409d36eceb23db402bb">IQ_COMP_BLOCK_SCALE_SUPPORT</a> = 0x04
, <a class="el" href="#ggac42ef3891485579391376bda5ac38175a1fff0e2d81acb56d50e40373a6692bcf">IQ_COMP_U_LAW_SUPPORT</a> = 0x08
, <br />
&#160;&#160;<a class="el" href="#ggac42ef3891485579391376bda5ac38175a305e7eb21ae5b81f3362e05a4f065580">IQ_COMP_MODULATION_SUPPORT</a> = 0x10
<br />
 }</td></tr>
<tr class="memdesc:gac42ef3891485579391376bda5ac38175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for supported IQ compression modes (bit-map).  <a href="#gac42ef3891485579391376bda5ac38175">More...</a><br /></td></tr>
<tr class="separator:gac42ef3891485579391376bda5ac38175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd0d1e2b2202d805a2c6e0d4546e2ca" id="r_ga9dd0d1e2b2202d805a2c6e0d4546e2ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9dd0d1e2b2202d805a2c6e0d4546e2ca">xorif_extra_flags</a> {  }</td></tr>
<tr class="memdesc:ga9dd0d1e2b2202d805a2c6e0d4546e2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type for extra capability bitmap flags.  <a href="#ga9dd0d1e2b2202d805a2c6e0d4546e2ca">More...</a><br /></td></tr>
<tr class="separator:ga9dd0d1e2b2202d805a2c6e0d4546e2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab913aef59d6dfeb48ca044dd311f80ba" id="r_gab913aef59d6dfeb48ca044dd311f80ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab913aef59d6dfeb48ca044dd311f80ba">xorif_fhi_alarms</a> { <br />
&#160;&#160;<a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baafd8ffe789f75abadac9aefafb4e1d4ee">FRAMER_RESET_STATUS</a> = 0x1
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baac016b81781957639286fb072a1774dcc">DEFRAMER_RESET_STATUS</a> = 0x2
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baad0cc8a23001566871c8e28f655ee923e">DEFRAMER_IN_FIFO_OF</a> = 0x100
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baa04722b8a21db88031242714a56e84b19">DEFRAMER_IN_FIFO_UF</a> = 0x200
, <br />
&#160;&#160;<a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baa48c541c16d67f948e2676d30d7b41508">DEFRAMER_ETH_CIRC_BUFF_OF</a> = 0x400
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baa850c75064999b9990a3bfec10d50ce5c">DEFRAMER_ETH_CIRC_BUFF_PTR_OF</a> = 0x800
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baaa82e656755b95d6d29e3bf4a99c18280">FRAMER_OUT_FIFO_OF</a> = 0x1000
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baa57c419410600e4aa01fff26f5dfebd36">FRAMER_OUT_FIFO_UF</a> = 0x2000
, <br />
&#160;&#160;<a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baaa61675bfc91f756829db3d59d09781bf">FRAMER_PRACH_SECTION_OF</a> = 0x4000
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baaa41d008ddcc6ae919186d8c5ec1d8458">FRAMER_PRACH_SECTION_NF</a> = 0x8000
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baa5e6d55216d4daa07e4243dbcb33b8361">FRAMER_SECTION_OF</a> = 0x10000
, <a class="el" href="#ggab913aef59d6dfeb48ca044dd311f80baa5a67c8e77f8a056ad5c3434345c5ab3a">AXI_TIMEOUT</a> = 0x80000000
<br />
 }</td></tr>
<tr class="memdesc:gab913aef59d6dfeb48ca044dd311f80ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerations for Front-Haul Interface alarm/status information.  <a href="#gab913aef59d6dfeb48ca044dd311f80ba">More...</a><br /></td></tr>
<tr class="separator:gab913aef59d6dfeb48ca044dd311f80ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa337ebb1c5833b3836fc96fd24e25d06" id="r_gaa337ebb1c5833b3836fc96fd24e25d06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa337ebb1c5833b3836fc96fd24e25d06">xorif_transport_protocol</a> { <a class="el" href="#ggaa337ebb1c5833b3836fc96fd24e25d06a9bdc78e1b1bf6c3322342d1c7ae4388b">PROTOCOL_ECPRI</a> = 0
, <a class="el" href="#ggaa337ebb1c5833b3836fc96fd24e25d06a6d3f3d36b1f8e6ca3dccc2946e648197">PROTOCOL_IEEE_1914_3</a> = 1
 }</td></tr>
<tr class="memdesc:gaa337ebb1c5833b3836fc96fd24e25d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerations for supported Front-Haul Interface transport protocols.  <a href="#gaa337ebb1c5833b3836fc96fd24e25d06">More...</a><br /></td></tr>
<tr class="separator:gaa337ebb1c5833b3836fc96fd24e25d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada146a3a3559be5ef31bf10fac14ff24" id="r_gada146a3a3559be5ef31bf10fac14ff24"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada146a3a3559be5ef31bf10fac14ff24">xorif_ip_mode</a> { <a class="el" href="#ggada146a3a3559be5ef31bf10fac14ff24a2637e615001e14c5b17fffb76774f0b9">IP_MODE_RAW</a> = 0
, <a class="el" href="#ggada146a3a3559be5ef31bf10fac14ff24af87e096d037258dfd371fbfc34d3af79">IP_MODE_IPV4</a> = 1
, <a class="el" href="#ggada146a3a3559be5ef31bf10fac14ff24a8bde3d623e49b6310e35dfa4f098e6bb">IP_MODE_IPV6</a> = 3
 }</td></tr>
<tr class="memdesc:gada146a3a3559be5ef31bf10fac14ff24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerations for supported Front-Haul Interface IP modes.  <a href="#gada146a3a3559be5ef31bf10fac14ff24">More...</a><br /></td></tr>
<tr class="separator:gada146a3a3559be5ef31bf10fac14ff24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0f0dc0574e1f6fe358edba1145216309" id="r_ga0f0dc0574e1f6fe358edba1145216309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f0dc0574e1f6fe358edba1145216309">xocp_debug</a> (uint16_t level)</td></tr>
<tr class="memdesc:ga0f0dc0574e1f6fe358edba1145216309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debug/trace level.  <br /></td></tr>
<tr class="separator:ga0f0dc0574e1f6fe358edba1145216309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ffd8a57c5d7222b30ee1e27dad3160" id="r_gaf6ffd8a57c5d7222b30ee1e27dad3160"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6ffd8a57c5d7222b30ee1e27dad3160">xocp_start</a> (void)</td></tr>
<tr class="memdesc:gaf6ffd8a57c5d7222b30ee1e27dad3160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a driver instance for the device.  <br /></td></tr>
<tr class="separator:gaf6ffd8a57c5d7222b30ee1e27dad3160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4357f21c80d21ba991eee6fb5e0ecb" id="r_gaab4357f21c80d21ba991eee6fb5e0ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaab4357f21c80d21ba991eee6fb5e0ecb">xocp_finish</a> (uint16_t instance)</td></tr>
<tr class="memdesc:gaab4357f21c80d21ba991eee6fb5e0ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close/finalize the driver instance.  <br /></td></tr>
<tr class="separator:gaab4357f21c80d21ba991eee6fb5e0ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6109de427bcae994b7b4c42aef71782" id="r_gaf6109de427bcae994b7b4c42aef71782"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6109de427bcae994b7b4c42aef71782">xocp_get_state</a> (uint16_t instance)</td></tr>
<tr class="memdesc:gaf6109de427bcae994b7b4c42aef71782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the device.  <br /></td></tr>
<tr class="separator:gaf6109de427bcae994b7b4c42aef71782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97785138a9cea8e247c6f412364d779c" id="r_ga97785138a9cea8e247c6f412364d779c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97785138a9cea8e247c6f412364d779c">xocp_get_sw_version</a> (void)</td></tr>
<tr class="memdesc:ga97785138a9cea8e247c6f412364d779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the s/w version.  <br /></td></tr>
<tr class="separator:ga97785138a9cea8e247c6f412364d779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10e3b7f3ff3a4269243b2cc70c20701" id="r_gaa10e3b7f3ff3a4269243b2cc70c20701"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa10e3b7f3ff3a4269243b2cc70c20701">xocp_get_hw_version</a> (uint16_t instance)</td></tr>
<tr class="memdesc:gaa10e3b7f3ff3a4269243b2cc70c20701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the h/w version.  <br /></td></tr>
<tr class="separator:gaa10e3b7f3ff3a4269243b2cc70c20701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82472d6cb2902604c41880c81683f849" id="r_ga82472d6cb2902604c41880c81683f849"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82472d6cb2902604c41880c81683f849">xocp_get_hw_internal_rev</a> (uint16_t instance)</td></tr>
<tr class="memdesc:ga82472d6cb2902604c41880c81683f849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal h/w revision.  <br /></td></tr>
<tr class="separator:ga82472d6cb2902604c41880c81683f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0a515e9398b7df6bb04e368295f398" id="r_ga2f0a515e9398b7df6bb04e368295f398"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f0a515e9398b7df6bb04e368295f398">xocp_get_capabilities</a> (uint16_t instance, struct <a class="el" href="structxocp__caps.html">xocp_caps</a> *data)</td></tr>
<tr class="memdesc:ga2f0a515e9398b7df6bb04e368295f398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device capabilities.  <br /></td></tr>
<tr class="separator:ga2f0a515e9398b7df6bb04e368295f398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e857e841f5ba6d44aaae733cc75db8e" id="r_ga2e857e841f5ba6d44aaae733cc75db8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e857e841f5ba6d44aaae733cc75db8e">xocp_get_event_status</a> (uint16_t instance, uint32_t *status)</td></tr>
<tr class="memdesc:ga2e857e841f5ba6d44aaae733cc75db8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current event status (e.g.  <br /></td></tr>
<tr class="separator:ga2e857e841f5ba6d44aaae733cc75db8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9614a06cd606c1f2a3deef32132dbead" id="r_ga9614a06cd606c1f2a3deef32132dbead"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9614a06cd606c1f2a3deef32132dbead">xocp_clear_event_status</a> (uint16_t instance)</td></tr>
<tr class="memdesc:ga9614a06cd606c1f2a3deef32132dbead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the current event status (e.g.  <br /></td></tr>
<tr class="separator:ga9614a06cd606c1f2a3deef32132dbead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbda271a8bfaaa3c8a1a0858a0ce4aa" id="r_ga2cbda271a8bfaaa3c8a1a0858a0ce4aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2cbda271a8bfaaa3c8a1a0858a0ce4aa">xocp_enable_interrupts</a> (uint16_t instance, uint32_t mask)</td></tr>
<tr class="memdesc:ga2cbda271a8bfaaa3c8a1a0858a0ce4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable the event interrupts (according to supplied mask).  <br /></td></tr>
<tr class="separator:ga2cbda271a8bfaaa3c8a1a0858a0ce4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25120e04d622474f04345064c902d006" id="r_ga25120e04d622474f04345064c902d006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25120e04d622474f04345064c902d006">xocp_register_event_callback</a> (uint16_t instance, <a class="el" href="#gaa2aee8cec3c52814f6b30da8f44871b0">xocp_isr_func_t</a> callback)</td></tr>
<tr class="memdesc:ga25120e04d622474f04345064c902d006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a call-back function for event interrupts.  <br /></td></tr>
<tr class="separator:ga25120e04d622474f04345064c902d006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c079fad72f78f8d9e86d53c8af7925" id="r_ga26c079fad72f78f8d9e86d53c8af7925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26c079fad72f78f8d9e86d53c8af7925">xocp_read_reg</a> (uint16_t instance, const char *name, uint32_t *value)</td></tr>
<tr class="memdesc:ga26c079fad72f78f8d9e86d53c8af7925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read from a register / register field on the device.  <br /></td></tr>
<tr class="separator:ga26c079fad72f78f8d9e86d53c8af7925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69819662d0460ed5afb7b183a6fb2d3" id="r_gad69819662d0460ed5afb7b183a6fb2d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad69819662d0460ed5afb7b183a6fb2d3">xocp_read_reg_offset</a> (uint16_t instance, const char *name, uint16_t offset, uint32_t *value)</td></tr>
<tr class="memdesc:gad69819662d0460ed5afb7b183a6fb2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read from a register / register field on the device.  <br /></td></tr>
<tr class="separator:gad69819662d0460ed5afb7b183a6fb2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga247c77c2b87ec6e01dbdfcb20c0716eb" id="r_ga247c77c2b87ec6e01dbdfcb20c0716eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga247c77c2b87ec6e01dbdfcb20c0716eb">xocp_write_reg</a> (uint16_t instance, const char *name, uint32_t value)</td></tr>
<tr class="memdesc:ga247c77c2b87ec6e01dbdfcb20c0716eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write to a register / register field on the device.  <br /></td></tr>
<tr class="separator:ga247c77c2b87ec6e01dbdfcb20c0716eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272a85ffed433b3d5fc91f33dba6d961" id="r_ga272a85ffed433b3d5fc91f33dba6d961"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga272a85ffed433b3d5fc91f33dba6d961">xocp_write_reg_offset</a> (uint16_t instance, const char *name, uint16_t offset, uint32_t value)</td></tr>
<tr class="memdesc:ga272a85ffed433b3d5fc91f33dba6d961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write to a register / register field on the device.  <br /></td></tr>
<tr class="separator:ga272a85ffed433b3d5fc91f33dba6d961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d34a3237dfd74eb86a302913c60de28" id="r_ga2d34a3237dfd74eb86a302913c60de28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d34a3237dfd74eb86a302913c60de28">xocp_reset</a> (uint16_t instance, uint8_t mode)</td></tr>
<tr class="memdesc:ga2d34a3237dfd74eb86a302913c60de28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the device and driver instance into reset.  <br /></td></tr>
<tr class="separator:ga2d34a3237dfd74eb86a302913c60de28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11cd61d97a8aa15b59980f476a157072" id="r_ga11cd61d97a8aa15b59980f476a157072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11cd61d97a8aa15b59980f476a157072">xocp_activate</a> (uint16_t instance)</td></tr>
<tr class="memdesc:ga11cd61d97a8aa15b59980f476a157072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate the O-RAN Channel Processor operation.  <br /></td></tr>
<tr class="separator:ga11cd61d97a8aa15b59980f476a157072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08ae7869a674d839707a4ab12723879" id="r_gae08ae7869a674d839707a4ab12723879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae08ae7869a674d839707a4ab12723879">xocp_get_cc_cfg</a> (uint16_t instance, uint8_t cc, struct <a class="el" href="structxocp__cc__data.html">xocp_cc_data</a> *data)</td></tr>
<tr class="memdesc:gae08ae7869a674d839707a4ab12723879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the component carrier configuration.  <br /></td></tr>
<tr class="separator:gae08ae7869a674d839707a4ab12723879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91cb69c970d87cb2de7a465935151a93" id="r_ga91cb69c970d87cb2de7a465935151a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91cb69c970d87cb2de7a465935151a93">xocp_set_cc_cfg</a> (uint16_t instance, uint8_t cc, const struct <a class="el" href="structxocp__cc__data.html">xocp_cc_data</a> *data)</td></tr>
<tr class="memdesc:ga91cb69c970d87cb2de7a465935151a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the component carrier configuration.  <br /></td></tr>
<tr class="separator:ga91cb69c970d87cb2de7a465935151a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1032c0396e64c059895441bca7a00b8" id="r_gad1032c0396e64c059895441bca7a00b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1032c0396e64c059895441bca7a00b8">xocp_get_antenna_cfg</a> (uint16_t instance, struct <a class="el" href="structxocp__antenna__data.html">xocp_antenna_data</a> *data)</td></tr>
<tr class="memdesc:gad1032c0396e64c059895441bca7a00b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the antenna configuration.  <br /></td></tr>
<tr class="separator:gad1032c0396e64c059895441bca7a00b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee188ec91e4704e86f24d134f84ac61" id="r_ga5ee188ec91e4704e86f24d134f84ac61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ee188ec91e4704e86f24d134f84ac61">xocp_set_antenna_cfg</a> (uint16_t instance, const struct <a class="el" href="structxocp__antenna__data.html">xocp_antenna_data</a> *data)</td></tr>
<tr class="memdesc:ga5ee188ec91e4704e86f24d134f84ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the antenna configuration.  <br /></td></tr>
<tr class="separator:ga5ee188ec91e4704e86f24d134f84ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80a5ea55ae57b99cfcc26dde3a54a20" id="r_gaf80a5ea55ae57b99cfcc26dde3a54a20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf80a5ea55ae57b99cfcc26dde3a54a20">xocp_set_schedule</a> (uint16_t instance, uint8_t mode, uint8_t length, const uint8_t sequence[])</td></tr>
<tr class="memdesc:gaf80a5ea55ae57b99cfcc26dde3a54a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "next" symbol processing schedule.  <br /></td></tr>
<tr class="separator:gaf80a5ea55ae57b99cfcc26dde3a54a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9cd8da6a264e8107fb4af205caa5fd" id="r_gabc9cd8da6a264e8107fb4af205caa5fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc9cd8da6a264e8107fb4af205caa5fd">xocp_get_trigger_cfg</a> (uint16_t instance, struct <a class="el" href="structxocp__triggers.html">xocp_triggers</a> *triggers)</td></tr>
<tr class="memdesc:gabc9cd8da6a264e8107fb4af205caa5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HW trigger configuration for DL/UL "update".  <br /></td></tr>
<tr class="separator:gabc9cd8da6a264e8107fb4af205caa5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faf33afeb951c812a95d195a5d1fbe5" id="r_ga6faf33afeb951c812a95d195a5d1fbe5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6faf33afeb951c812a95d195a5d1fbe5">xocp_set_trigger_cfg</a> (uint16_t instance, const struct <a class="el" href="structxocp__triggers.html">xocp_triggers</a> *triggers)</td></tr>
<tr class="memdesc:ga6faf33afeb951c812a95d195a5d1fbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the HW trigger configuration for DL/UL "update".  <br /></td></tr>
<tr class="separator:ga6faf33afeb951c812a95d195a5d1fbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6194042bff2a266ae3ebad7000cade4" id="r_gaf6194042bff2a266ae3ebad7000cade4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6194042bff2a266ae3ebad7000cade4">xocp_trigger_update</a> (uint16_t instance)</td></tr>
<tr class="memdesc:gaf6194042bff2a266ae3ebad7000cade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the "update" HW trigger.  <br /></td></tr>
<tr class="separator:gaf6194042bff2a266ae3ebad7000cade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71441ce4e335da460f0044cac1eaaf34" id="r_ga71441ce4e335da460f0044cac1eaaf34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71441ce4e335da460f0044cac1eaaf34">xocp_monitor_clear</a> (uint16_t instance)</td></tr>
<tr class="memdesc:ga71441ce4e335da460f0044cac1eaaf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all "monitor block" counters.  <br /></td></tr>
<tr class="separator:ga71441ce4e335da460f0044cac1eaaf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2e5d420ec409de195f1be04a42ae4a" id="r_gaed2e5d420ec409de195f1be04a42ae4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed2e5d420ec409de195f1be04a42ae4a">xocp_monitor_snapshot</a> (uint16_t instance)</td></tr>
<tr class="memdesc:gaed2e5d420ec409de195f1be04a42ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take snapshot of the "monitor block" counters.  <br /></td></tr>
<tr class="separator:gaed2e5d420ec409de195f1be04a42ae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad336b80523a9f214e2c026a68ec12bc1" id="r_gad336b80523a9f214e2c026a68ec12bc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad336b80523a9f214e2c026a68ec12bc1">xocp_monitor_read</a> (uint16_t instance, uint8_t counter, uint64_t *value)</td></tr>
<tr class="memdesc:gad336b80523a9f214e2c026a68ec12bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read specified counter from "monitor block".  <br /></td></tr>
<tr class="separator:gad336b80523a9f214e2c026a68ec12bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c1601fb0d91568c305ecf8fdf87811" id="r_gac3c1601fb0d91568c305ecf8fdf87811"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3c1601fb0d91568c305ecf8fdf87811">xorif_get_state</a> (void)</td></tr>
<tr class="memdesc:gac3c1601fb0d91568c305ecf8fdf87811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the library.  <br /></td></tr>
<tr class="separator:gac3c1601fb0d91568c305ecf8fdf87811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060c30abe081322ad6caeaaf99b0ef07" id="r_ga060c30abe081322ad6caeaaf99b0ef07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga060c30abe081322ad6caeaaf99b0ef07">xorif_debug</a> (int level)</td></tr>
<tr class="memdesc:ga060c30abe081322ad6caeaaf99b0ef07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debug level for the library.  <br /></td></tr>
<tr class="separator:ga060c30abe081322ad6caeaaf99b0ef07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3a3d79d4361a962e11f28fefaafc36" id="r_ga9d3a3d79d4361a962e11f28fefaafc36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9d3a3d79d4361a962e11f28fefaafc36">xorif_init</a> (const char *device_name)</td></tr>
<tr class="memdesc:ga9d3a3d79d4361a962e11f28fefaafc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the API s/w.  <br /></td></tr>
<tr class="separator:ga9d3a3d79d4361a962e11f28fefaafc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14608b52109708bd77364f9b7b19e3c1" id="r_ga14608b52109708bd77364f9b7b19e3c1"><td class="memItemLeft" align="right" valign="top"><a id="ga14608b52109708bd77364f9b7b19e3c1" name="ga14608b52109708bd77364f9b7b19e3c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xorif_finish</b> (void)</td></tr>
<tr class="memdesc:ga14608b52109708bd77364f9b7b19e3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize / close the API s/w. <br /></td></tr>
<tr class="separator:ga14608b52109708bd77364f9b7b19e3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5031b867d3c6588655036dabd56fa05" id="r_gac5031b867d3c6588655036dabd56fa05"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5031b867d3c6588655036dabd56fa05">xorif_get_sw_version</a> (void)</td></tr>
<tr class="memdesc:gac5031b867d3c6588655036dabd56fa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the s/w version.  <br /></td></tr>
<tr class="separator:gac5031b867d3c6588655036dabd56fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325b96c5f53b0bdfb57f535035ffbe8d" id="r_ga325b96c5f53b0bdfb57f535035ffbe8d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga325b96c5f53b0bdfb57f535035ffbe8d">xorif_get_fhi_hw_version</a> (void)</td></tr>
<tr class="memdesc:ga325b96c5f53b0bdfb57f535035ffbe8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Front-Haul Interface h/w version.  <br /></td></tr>
<tr class="separator:ga325b96c5f53b0bdfb57f535035ffbe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2358c0211954f64b207879fe43e0e5bb" id="r_ga2358c0211954f64b207879fe43e0e5bb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2358c0211954f64b207879fe43e0e5bb">xorif_get_fhi_hw_internal_rev</a> (void)</td></tr>
<tr class="memdesc:ga2358c0211954f64b207879fe43e0e5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Front-Haul Interface h/w internal revision number.  <br /></td></tr>
<tr class="separator:ga2358c0211954f64b207879fe43e0e5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f699ac3378d0485e8dae26c60a0b79" id="r_ga83f699ac3378d0485e8dae26c60a0b79"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structxorif__caps.html">xorif_caps</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83f699ac3378d0485e8dae26c60a0b79">xorif_get_capabilities</a> (void)</td></tr>
<tr class="memdesc:ga83f699ac3378d0485e8dae26c60a0b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Front-Haul Interface capabilities.  <br /></td></tr>
<tr class="separator:ga83f699ac3378d0485e8dae26c60a0b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354bba5bbf86cb1a6ea346e47590cb5b" id="r_ga354bba5bbf86cb1a6ea346e47590cb5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga354bba5bbf86cb1a6ea346e47590cb5b">xorif_has_front_haul_interface</a> (void)</td></tr>
<tr class="memdesc:ga354bba5bbf86cb1a6ea346e47590cb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is a O-RAN makeFront-Haul Interface in the system.  <br /></td></tr>
<tr class="separator:ga354bba5bbf86cb1a6ea346e47590cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c512ca218a568fdbeffacd599bfbf27" id="r_ga0c512ca218a568fdbeffacd599bfbf27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0c512ca218a568fdbeffacd599bfbf27">xorif_has_oran_channel_processor</a> (void)</td></tr>
<tr class="memdesc:ga0c512ca218a568fdbeffacd599bfbf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is a O-RAN Channel Processor in the system.  <br /></td></tr>
<tr class="separator:ga0c512ca218a568fdbeffacd599bfbf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d073a6ce61f808a5489f61a721a41b" id="r_ga60d073a6ce61f808a5489f61a721a41b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga60d073a6ce61f808a5489f61a721a41b">xorif_configure_cc</a> (uint16_t cc)</td></tr>
<tr class="memdesc:ga60d073a6ce61f808a5489f61a721a41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a component carrier.  <br /></td></tr>
<tr class="separator:ga60d073a6ce61f808a5489f61a721a41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3839531a2c838f6d1a0185d39efdb6" id="r_ga7b3839531a2c838f6d1a0185d39efdb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b3839531a2c838f6d1a0185d39efdb6">xorif_enable_cc</a> (uint16_t cc)</td></tr>
<tr class="memdesc:ga7b3839531a2c838f6d1a0185d39efdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the specified component carrier.  <br /></td></tr>
<tr class="separator:ga7b3839531a2c838f6d1a0185d39efdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4aa0e1740018435969fe845e647a58" id="r_ga4e4aa0e1740018435969fe845e647a58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4e4aa0e1740018435969fe845e647a58">xorif_disable_cc</a> (uint16_t cc)</td></tr>
<tr class="memdesc:ga4e4aa0e1740018435969fe845e647a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the specified component carrier.  <br /></td></tr>
<tr class="separator:ga4e4aa0e1740018435969fe845e647a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94ca3eccdfae718818dd0cb1cd248e8" id="r_gaf94ca3eccdfae718818dd0cb1cd248e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf94ca3eccdfae718818dd0cb1cd248e8">xorif_get_enabled_cc_mask</a> (void)</td></tr>
<tr class="memdesc:gaf94ca3eccdfae718818dd0cb1cd248e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a bit-map of enabled component carriers.  <br /></td></tr>
<tr class="separator:gaf94ca3eccdfae718818dd0cb1cd248e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9760fd53b96007a0c917a22c1f4a73d6" id="r_ga9760fd53b96007a0c917a22c1f4a73d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9760fd53b96007a0c917a22c1f4a73d6">xorif_set_cc_config</a> (uint16_t cc, const struct <a class="el" href="structxorif__cc__config.html">xorif_cc_config</a> *ptr)</td></tr>
<tr class="memdesc:ga9760fd53b96007a0c917a22c1f4a73d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the configuration for the component carrier.  <br /></td></tr>
<tr class="separator:ga9760fd53b96007a0c917a22c1f4a73d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5f8f7f67104640dc59f48e23e03bf0" id="r_ga5b5f8f7f67104640dc59f48e23e03bf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b5f8f7f67104640dc59f48e23e03bf0">xorif_get_cc_config</a> (uint16_t cc, struct <a class="el" href="structxorif__cc__config.html">xorif_cc_config</a> *ptr)</td></tr>
<tr class="memdesc:ga5b5f8f7f67104640dc59f48e23e03bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configuration for the component carrier.  <br /></td></tr>
<tr class="separator:ga5b5f8f7f67104640dc59f48e23e03bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bb9cbc4aae17d9db299f7a7595efa0" id="r_gac5bb9cbc4aae17d9db299f7a7595efa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5bb9cbc4aae17d9db299f7a7595efa0">xorif_set_cc_num_rbs</a> (uint16_t cc, uint16_t num_rbs)</td></tr>
<tr class="memdesc:gac5bb9cbc4aae17d9db299f7a7595efa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of RBs for the component carrier.  <br /></td></tr>
<tr class="separator:gac5bb9cbc4aae17d9db299f7a7595efa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3da356c6483228f09c42c2f5e2136e" id="r_ga4a3da356c6483228f09c42c2f5e2136e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a3da356c6483228f09c42c2f5e2136e">xorif_set_cc_numerology</a> (uint16_t cc, uint16_t numerology, uint16_t extended_cp)</td></tr>
<tr class="memdesc:ga4a3da356c6483228f09c42c2f5e2136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the numerology for the component carrier.  <br /></td></tr>
<tr class="separator:ga4a3da356c6483228f09c42c2f5e2136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd1067dc7af1a96676441b93b0b8bb0" id="r_ga9fd1067dc7af1a96676441b93b0b8bb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9fd1067dc7af1a96676441b93b0b8bb0">xorif_set_cc_num_rbs_ssb</a> (uint16_t cc, uint16_t num_rbs)</td></tr>
<tr class="memdesc:ga9fd1067dc7af1a96676441b93b0b8bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of RBs for the component carrier' SSB.  <br /></td></tr>
<tr class="separator:ga9fd1067dc7af1a96676441b93b0b8bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3373c25f26f3e81c2cd24f22f1ff807" id="r_gac3373c25f26f3e81c2cd24f22f1ff807"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3373c25f26f3e81c2cd24f22f1ff807">xorif_set_cc_numerology_ssb</a> (uint16_t cc, uint16_t numerology, uint16_t extended_cp)</td></tr>
<tr class="memdesc:gac3373c25f26f3e81c2cd24f22f1ff807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the numerology for the component carrier's SSB.  <br /></td></tr>
<tr class="separator:gac3373c25f26f3e81c2cd24f22f1ff807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3201eb51ec95a208a12a952da12fa26" id="r_gaa3201eb51ec95a208a12a952da12fa26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa3201eb51ec95a208a12a952da12fa26">xorif_set_cc_time_advance</a> (uint16_t cc, double deskew, double advance_ul, double advance_dl)</td></tr>
<tr class="memdesc:gaa3201eb51ec95a208a12a952da12fa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum deskew and control advance timing for the component carrier.  <br /></td></tr>
<tr class="separator:gaa3201eb51ec95a208a12a952da12fa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fc75de00d2748b74ca7662e9ff5c5e" id="r_gaf9fc75de00d2748b74ca7662e9ff5c5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9fc75de00d2748b74ca7662e9ff5c5e">xorif_set_cc_ul_timing_parameters</a> (uint16_t cc, double delay_comp_cp, double advance, double radio_ch_delay)</td></tr>
<tr class="memdesc:gaf9fc75de00d2748b74ca7662e9ff5c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the uplink timing parameters for the component carrier.  <br /></td></tr>
<tr class="separator:gaf9fc75de00d2748b74ca7662e9ff5c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43336d896069b72003f112aae1f396d" id="r_gaf43336d896069b72003f112aae1f396d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf43336d896069b72003f112aae1f396d">xorif_set_cc_dl_timing_parameters</a> (uint16_t cc, double delay_comp_cp, double delay_comp_up, double advance)</td></tr>
<tr class="memdesc:gaf43336d896069b72003f112aae1f396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the downlink timing parameters for the component carrier.  <br /></td></tr>
<tr class="separator:gaf43336d896069b72003f112aae1f396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1fa8a5ab92c334994a32f2d83e65fd" id="r_ga2b1fa8a5ab92c334994a32f2d83e65fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b1fa8a5ab92c334994a32f2d83e65fd">xorif_set_ul_bid_forward</a> (uint16_t cc, double time)</td></tr>
<tr class="memdesc:ga2b1fa8a5ab92c334994a32f2d83e65fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the uplink beam-id forward time for the component carrier.  <br /></td></tr>
<tr class="separator:ga2b1fa8a5ab92c334994a32f2d83e65fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5ebd79d6d83c0d6e37eff6cb7465d9" id="r_ga4f5ebd79d6d83c0d6e37eff6cb7465d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f5ebd79d6d83c0d6e37eff6cb7465d9">xorif_set_ul_radio_ch_dly</a> (uint16_t cc, double delay)</td></tr>
<tr class="memdesc:ga4f5ebd79d6d83c0d6e37eff6cb7465d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the uplink radio channel delay estimate for the component carrier.  <br /></td></tr>
<tr class="separator:ga4f5ebd79d6d83c0d6e37eff6cb7465d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa069ac48f7c01a52c0c28d83b1153d95" id="r_gaa069ac48f7c01a52c0c28d83b1153d95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa069ac48f7c01a52c0c28d83b1153d95">xorif_set_cc_dl_iq_compression</a> (uint16_t cc, uint16_t bit_width, enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a> comp_method, uint16_t mplane)</td></tr>
<tr class="memdesc:gaa069ac48f7c01a52c0c28d83b1153d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the downlink IQ compression for the component carrier.  <br /></td></tr>
<tr class="separator:gaa069ac48f7c01a52c0c28d83b1153d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e7a76564f554192277acd1852e3ad" id="r_gade9e7a76564f554192277acd1852e3ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade9e7a76564f554192277acd1852e3ad">xorif_set_cc_dl_iq_compression_per_ss</a> (uint16_t ss, uint16_t bit_width, enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a> comp_method, uint16_t enable, uint16_t number)</td></tr>
<tr class="memdesc:gade9e7a76564f554192277acd1852e3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the downlink IQ compression per spatial stream.  <br /></td></tr>
<tr class="separator:gade9e7a76564f554192277acd1852e3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae73ee046a29f31dcaec51ea42c674e" id="r_ga5ae73ee046a29f31dcaec51ea42c674e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ae73ee046a29f31dcaec51ea42c674e">xorif_set_cc_ul_iq_compression</a> (uint16_t cc, uint16_t bit_width, enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a> comp_method, uint16_t mplane)</td></tr>
<tr class="memdesc:ga5ae73ee046a29f31dcaec51ea42c674e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the uplink IQ compression for the component carrier.  <br /></td></tr>
<tr class="separator:ga5ae73ee046a29f31dcaec51ea42c674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc9a1a8a947162d98100ab2e92171da" id="r_gaedc9a1a8a947162d98100ab2e92171da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaedc9a1a8a947162d98100ab2e92171da">xorif_set_cc_iq_compression_ssb</a> (uint16_t cc, uint16_t bit_width, enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a> comp_method, uint16_t mplane)</td></tr>
<tr class="memdesc:gaedc9a1a8a947162d98100ab2e92171da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the SSB compression for the component carrier.  <br /></td></tr>
<tr class="separator:gaedc9a1a8a947162d98100ab2e92171da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a935e45b74a6ed2766f286a6bc21d3" id="r_ga29a935e45b74a6ed2766f286a6bc21d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga29a935e45b74a6ed2766f286a6bc21d3">xorif_set_cc_iq_compression_prach</a> (uint16_t cc, uint16_t bit_width, enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a> comp_method, uint16_t mplane)</td></tr>
<tr class="memdesc:ga29a935e45b74a6ed2766f286a6bc21d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the PRACH compression for the component carrier.  <br /></td></tr>
<tr class="separator:ga29a935e45b74a6ed2766f286a6bc21d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebaccf31445eb3da67493984f26e3fba" id="r_gaebaccf31445eb3da67493984f26e3fba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaebaccf31445eb3da67493984f26e3fba">xorif_set_cc_dl_sections_per_symbol</a> (uint16_t cc, uint16_t num_sect, uint16_t num_ctrl)</td></tr>
<tr class="memdesc:gaebaccf31445eb3da67493984f26e3fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the number of sections and ctrl words per downlink symbol.  <br /></td></tr>
<tr class="separator:gaebaccf31445eb3da67493984f26e3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8791772c6c278a79420538c9b0df202d" id="r_ga8791772c6c278a79420538c9b0df202d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8791772c6c278a79420538c9b0df202d">xorif_set_cc_ul_sections_per_symbol</a> (uint16_t cc, uint16_t num_sect, uint16_t num_ctrl)</td></tr>
<tr class="memdesc:ga8791772c6c278a79420538c9b0df202d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the number of sections and ctrl words per uplink symbol.  <br /></td></tr>
<tr class="separator:ga8791772c6c278a79420538c9b0df202d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891c7e0622f34429e09023f7d64e54d0" id="r_ga891c7e0622f34429e09023f7d64e54d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga891c7e0622f34429e09023f7d64e54d0">xorif_set_cc_frames_per_symbol</a> (uint16_t cc, uint16_t num_frames)</td></tr>
<tr class="memdesc:ga891c7e0622f34429e09023f7d64e54d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the number of Ethernet frames per downlink symbol.  <br /></td></tr>
<tr class="separator:ga891c7e0622f34429e09023f7d64e54d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b800f4ca34e642e206e29a2abb6c6a" id="r_ga13b800f4ca34e642e206e29a2abb6c6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga13b800f4ca34e642e206e29a2abb6c6a">xorif_set_cc_sections_per_symbol_ssb</a> (uint16_t cc, uint16_t num_sect, uint16_t num_ctrl)</td></tr>
<tr class="memdesc:ga13b800f4ca34e642e206e29a2abb6c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the number of sections and ctrl words per SSB symbol.  <br /></td></tr>
<tr class="separator:ga13b800f4ca34e642e206e29a2abb6c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c4dcf40c1bac85c7ff288b02b443f3" id="r_ga58c4dcf40c1bac85c7ff288b02b443f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58c4dcf40c1bac85c7ff288b02b443f3">xorif_set_cc_frames_per_symbol_ssb</a> (uint16_t cc, uint16_t num_frames)</td></tr>
<tr class="memdesc:ga58c4dcf40c1bac85c7ff288b02b443f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the number of Ethernet frames allowed per SSB symbol.  <br /></td></tr>
<tr class="separator:ga58c4dcf40c1bac85c7ff288b02b443f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33241710e1a63e9329a0bbd7fb7b3039" id="r_ga33241710e1a63e9329a0bbd7fb7b3039"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga33241710e1a63e9329a0bbd7fb7b3039">xorif_reset_fhi</a> (uint16_t mode)</td></tr>
<tr class="memdesc:ga33241710e1a63e9329a0bbd7fb7b3039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the Front-Haul Interface.  <br /></td></tr>
<tr class="separator:ga33241710e1a63e9329a0bbd7fb7b3039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea741fbc93e935af409a051a4ab15e12" id="r_gaea741fbc93e935af409a051a4ab15e12"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea741fbc93e935af409a051a4ab15e12">xorif_get_fhi_alarms</a> (void)</td></tr>
<tr class="memdesc:gaea741fbc93e935af409a051a4ab15e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get alarms for Front-Haul Interface.  <br /></td></tr>
<tr class="separator:gaea741fbc93e935af409a051a4ab15e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957933b57af28961b2bc5635aa7b7e28" id="r_ga957933b57af28961b2bc5635aa7b7e28"><td class="memItemLeft" align="right" valign="top"><a id="ga957933b57af28961b2bc5635aa7b7e28" name="ga957933b57af28961b2bc5635aa7b7e28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xorif_clear_fhi_alarms</b> (void)</td></tr>
<tr class="memdesc:ga957933b57af28961b2bc5635aa7b7e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear alarms for Front-Haul Interface. <br /></td></tr>
<tr class="separator:ga957933b57af28961b2bc5635aa7b7e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga428a788b5c018bbcd535da829b208721" id="r_ga428a788b5c018bbcd535da829b208721"><td class="memItemLeft" align="right" valign="top"><a id="ga428a788b5c018bbcd535da829b208721" name="ga428a788b5c018bbcd535da829b208721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xorif_clear_fhi_stats</b> (void)</td></tr>
<tr class="memdesc:ga428a788b5c018bbcd535da829b208721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stats / counters for Front-Haul Interface. <br /></td></tr>
<tr class="separator:ga428a788b5c018bbcd535da829b208721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09430b3cb4720a008415205497c3675" id="r_gad09430b3cb4720a008415205497c3675"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad09430b3cb4720a008415205497c3675">xorif_get_fhi_cc_alloc</a> (uint16_t cc, struct <a class="el" href="structxorif__cc__alloc.html">xorif_cc_alloc</a> *ptr)</td></tr>
<tr class="memdesc:gad09430b3cb4720a008415205497c3675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the configured allocation for the specified component carrier.  <br /></td></tr>
<tr class="separator:gad09430b3cb4720a008415205497c3675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f0df0585606c4660e267b34ecd2077" id="r_ga83f0df0585606c4660e267b34ecd2077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83f0df0585606c4660e267b34ecd2077">xorif_read_fhi_reg</a> (const char *name, uint32_t *val)</td></tr>
<tr class="memdesc:ga83f0df0585606c4660e267b34ecd2077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to read a field from the Front-Haul Interface register map.  <br /></td></tr>
<tr class="separator:ga83f0df0585606c4660e267b34ecd2077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0dd7c8f1d053aa5b62bbdc53366bc2" id="r_gadc0dd7c8f1d053aa5b62bbdc53366bc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc0dd7c8f1d053aa5b62bbdc53366bc2">xorif_read_fhi_reg_offset</a> (const char *name, uint16_t offset, uint32_t *val)</td></tr>
<tr class="memdesc:gadc0dd7c8f1d053aa5b62bbdc53366bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to read a field from the Front-Haul Interface register map.  <br /></td></tr>
<tr class="separator:gadc0dd7c8f1d053aa5b62bbdc53366bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c6289aa4a4970e2e6c2244d876b20b" id="r_gac5c6289aa4a4970e2e6c2244d876b20b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5c6289aa4a4970e2e6c2244d876b20b">xorif_write_fhi_reg</a> (const char *name, uint32_t value)</td></tr>
<tr class="memdesc:gac5c6289aa4a4970e2e6c2244d876b20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to write a field to the Front-Haul Interface register map.  <br /></td></tr>
<tr class="separator:gac5c6289aa4a4970e2e6c2244d876b20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58421571a3f2bf166aeb91fcdfdaa036" id="r_ga58421571a3f2bf166aeb91fcdfdaa036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58421571a3f2bf166aeb91fcdfdaa036">xorif_write_fhi_reg_offset</a> (const char *name, uint16_t offset, uint32_t value)</td></tr>
<tr class="memdesc:ga58421571a3f2bf166aeb91fcdfdaa036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to write a field to the Front-Haul Interface register map.  <br /></td></tr>
<tr class="separator:ga58421571a3f2bf166aeb91fcdfdaa036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a6fd499b68bfb88d4d3b8d61182ce74" id="r_ga1a6fd499b68bfb88d4d3b8d61182ce74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a6fd499b68bfb88d4d3b8d61182ce74">xorif_get_fhi_eth_stats</a> (int port, struct <a class="el" href="structxorif__fhi__eth__stats.html">xorif_fhi_eth_stats</a> *ptr)</td></tr>
<tr class="memdesc:ga1a6fd499b68bfb88d4d3b8d61182ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Front-Haul Interface Ethernet statistics for the specified port.  <br /></td></tr>
<tr class="separator:ga1a6fd499b68bfb88d4d3b8d61182ce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ade05b06d847a6a4487dbd7f27ac315" id="r_ga5ade05b06d847a6a4487dbd7f27ac315"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ade05b06d847a6a4487dbd7f27ac315">xorif_set_fhi_dest_mac_addr</a> (int port, const uint8_t address[])</td></tr>
<tr class="memdesc:ga5ade05b06d847a6a4487dbd7f27ac315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination ethernet MAC address for the specified port.  <br /></td></tr>
<tr class="separator:ga5ade05b06d847a6a4487dbd7f27ac315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e2fed6728de86a1a1f9d8d1880ff0d" id="r_gab5e2fed6728de86a1a1f9d8d1880ff0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5e2fed6728de86a1a1f9d8d1880ff0d">xorif_set_fhi_src_mac_addr</a> (int port, const uint8_t address[])</td></tr>
<tr class="memdesc:gab5e2fed6728de86a1a1f9d8d1880ff0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the source ethernet MAC address for the specified port.  <br /></td></tr>
<tr class="separator:gab5e2fed6728de86a1a1f9d8d1880ff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12c71caeba9b52a930a9b4848471f58" id="r_gac12c71caeba9b52a930a9b4848471f58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac12c71caeba9b52a930a9b4848471f58">xorif_set_modu_mode</a> (uint16_t enable)</td></tr>
<tr class="memdesc:gac12c71caeba9b52a930a9b4848471f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable the multi-O-DU MAC address / VLAN tag mapping.  <br /></td></tr>
<tr class="separator:gac12c71caeba9b52a930a9b4848471f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ffe1b4e867ecfce419bd59bb6c12b6" id="r_ga38ffe1b4e867ecfce419bd59bb6c12b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38ffe1b4e867ecfce419bd59bb6c12b6">xorif_set_modu_dest_mac_addr</a> (uint16_t du, const uint8_t address[], uint16_t id, uint16_t dei, uint16_t pcp)</td></tr>
<tr class="memdesc:ga38ffe1b4e867ecfce419bd59bb6c12b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the multi-O-DU MAC address / VLAN tag mapping for DU port address.  <br /></td></tr>
<tr class="separator:ga38ffe1b4e867ecfce419bd59bb6c12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadece8f9464fdb7b1056a4f45bd313dfe" id="r_gadece8f9464fdb7b1056a4f45bd313dfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadece8f9464fdb7b1056a4f45bd313dfe">xorif_set_mtu_size</a> (uint16_t size)</td></tr>
<tr class="memdesc:gadece8f9464fdb7b1056a4f45bd313dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the uplink MTU size.  <br /></td></tr>
<tr class="separator:gadece8f9464fdb7b1056a4f45bd313dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e5758db6df0d589c86337d9268278d" id="r_gaa3e5758db6df0d589c86337d9268278d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa3e5758db6df0d589c86337d9268278d">xorif_set_fhi_protocol</a> (enum <a class="el" href="#gaa337ebb1c5833b3836fc96fd24e25d06">xorif_transport_protocol</a> transport, uint16_t vlan, enum <a class="el" href="#gada146a3a3559be5ef31bf10fac14ff24">xorif_ip_mode</a> ip_mode)</td></tr>
<tr class="memdesc:gaa3e5758db6df0d589c86337d9268278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the protocol, vlan and IP mode.  <br /></td></tr>
<tr class="separator:gaa3e5758db6df0d589c86337d9268278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9924458bf10f080b305ec9e8f7858e" id="r_ga0f9924458bf10f080b305ec9e8f7858e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f9924458bf10f080b305ec9e8f7858e">xorif_set_fhi_protocol_alt</a> (enum <a class="el" href="#gaa337ebb1c5833b3836fc96fd24e25d06">xorif_transport_protocol</a> transport, uint16_t vlan, enum <a class="el" href="#gada146a3a3559be5ef31bf10fac14ff24">xorif_ip_mode</a> ip_mode)</td></tr>
<tr class="memdesc:ga0f9924458bf10f080b305ec9e8f7858e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the protocol, vlan and IP mode.  <br /></td></tr>
<tr class="separator:ga0f9924458bf10f080b305ec9e8f7858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e46206326f26259890154207ba55d4" id="r_ga39e46206326f26259890154207ba55d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga39e46206326f26259890154207ba55d4">xorif_set_fhi_vlan_tag</a> (int port, uint16_t id, uint16_t dei, uint16_t pcp)</td></tr>
<tr class="memdesc:ga39e46206326f26259890154207ba55d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the VLAN tag for the specified port.  <br /></td></tr>
<tr class="separator:ga39e46206326f26259890154207ba55d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac40979657aa87123b4cc380182829cde" id="r_gac40979657aa87123b4cc380182829cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac40979657aa87123b4cc380182829cde">xorif_set_fhi_packet_filter</a> (int port, const uint32_t filter[16], uint16_t mask[4])</td></tr>
<tr class="memdesc:gac40979657aa87123b4cc380182829cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the packet filter for the specified port.  <br /></td></tr>
<tr class="separator:gac40979657aa87123b4cc380182829cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550a91743d3aa995cc2c3c550d3afd72" id="r_ga550a91743d3aa995cc2c3c550d3afd72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga550a91743d3aa995cc2c3c550d3afd72">xorif_set_fhi_eaxc_id</a> (uint16_t du_bits, uint16_t bs_bits, uint16_t cc_bits, uint16_t ru_bits)</td></tr>
<tr class="memdesc:ga550a91743d3aa995cc2c3c550d3afd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the eAxC ID (c.f.  <br /></td></tr>
<tr class="separator:ga550a91743d3aa995cc2c3c550d3afd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857309ea8ff7506568e3111761877eb8" id="r_ga857309ea8ff7506568e3111761877eb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga857309ea8ff7506568e3111761877eb8">xorif_set_ru_ports</a> (uint16_t ru_bits, uint16_t ss_bits, uint16_t mask, uint16_t user_val, uint16_t prach_val, uint16_t ssb_val)</td></tr>
<tr class="memdesc:ga857309ea8ff7506568e3111761877eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RU port ID bits.  <br /></td></tr>
<tr class="separator:ga857309ea8ff7506568e3111761877eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9379066763d5ba7f1c7aa95467a2b69c" id="r_ga9379066763d5ba7f1c7aa95467a2b69c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9379066763d5ba7f1c7aa95467a2b69c">xorif_set_ru_ports_lte</a> (uint16_t ru_bits, uint16_t ss_bits, uint16_t mask, uint16_t user_val, uint16_t prach_val, uint16_t ssb_val, uint16_t lte_val)</td></tr>
<tr class="memdesc:ga9379066763d5ba7f1c7aa95467a2b69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RU port ID bits (alternative API, including LTE).  <br /></td></tr>
<tr class="separator:ga9379066763d5ba7f1c7aa95467a2b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e5936a62ac2c0a803c96adcc735fb7" id="r_ga02e5936a62ac2c0a803c96adcc735fb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga02e5936a62ac2c0a803c96adcc735fb7">xorif_set_ru_ports_table_mode</a> (uint16_t mode, uint16_t sub_mode)</td></tr>
<tr class="memdesc:ga02e5936a62ac2c0a803c96adcc735fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RU port table mapping mode.  <br /></td></tr>
<tr class="separator:ga02e5936a62ac2c0a803c96adcc735fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f12916f671ba6ee001f71f7f308e991" id="r_ga5f12916f671ba6ee001f71f7f308e991"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f12916f671ba6ee001f71f7f308e991">xorif_clear_ru_ports_table</a> (void)</td></tr>
<tr class="memdesc:ga5f12916f671ba6ee001f71f7f308e991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the RU ports mapping table.  <br /></td></tr>
<tr class="separator:ga5f12916f671ba6ee001f71f7f308e991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc3068a93476321d8449fcc7871a29f" id="r_ga6fc3068a93476321d8449fcc7871a29f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fc3068a93476321d8449fcc7871a29f">xorif_set_ru_ports_table</a> (uint16_t address, uint16_t port, uint16_t type, uint16_t number)</td></tr>
<tr class="memdesc:ga6fc3068a93476321d8449fcc7871a29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign one or more RU port id mappings.  <br /></td></tr>
<tr class="separator:ga6fc3068a93476321d8449fcc7871a29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c351b7236674c869768299e67127b1f" id="r_ga0c351b7236674c869768299e67127b1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0c351b7236674c869768299e67127b1f">xorif_set_ru_ports_table_vcc</a> (uint16_t address, uint16_t port, uint16_t type, uint16_t ccid, uint16_t number)</td></tr>
<tr class="memdesc:ga0c351b7236674c869768299e67127b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign one or more RU port id mappings (alternative with "Virtual CCID").  <br /></td></tr>
<tr class="separator:ga0c351b7236674c869768299e67127b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eaaa1adb6e01922ff4576bd4e816a72" id="r_ga4eaaa1adb6e01922ff4576bd4e816a72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4eaaa1adb6e01922ff4576bd4e816a72">xorif_enable_fhi_interrupts</a> (uint32_t mask)</td></tr>
<tr class="memdesc:ga4eaaa1adb6e01922ff4576bd4e816a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable Front-Haul Interface interrupts.  <br /></td></tr>
<tr class="separator:ga4eaaa1adb6e01922ff4576bd4e816a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20531a711869b69d9015727d99047531" id="r_ga20531a711869b69d9015727d99047531"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20531a711869b69d9015727d99047531">xorif_register_fhi_isr</a> (<a class="el" href="#ga8faee7bbc7441a5fcbfa86e44a838fcf">isr_func_t</a> callback)</td></tr>
<tr class="memdesc:ga20531a711869b69d9015727d99047531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a call-back function for Front-Haul Interface alarm interrupts.  <br /></td></tr>
<tr class="separator:ga20531a711869b69d9015727d99047531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c35a9fac66256693c3a76f7cfc654c1" id="r_ga5c35a9fac66256693c3a76f7cfc654c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c35a9fac66256693c3a76f7cfc654c1">xorif_set_system_constants</a> (const struct <a class="el" href="structxorif__system__constants.html">xorif_system_constants</a> *ptr)</td></tr>
<tr class="memdesc:ga5c35a9fac66256693c3a76f7cfc654c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set system "constants".  <br /></td></tr>
<tr class="separator:ga5c35a9fac66256693c3a76f7cfc654c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138c2d8d93188139c957e83ebcf59d70" id="r_ga138c2d8d93188139c957e83ebcf59d70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga138c2d8d93188139c957e83ebcf59d70">xorif_set_symbol_strobe_source</a> (uint16_t source)</td></tr>
<tr class="memdesc:ga138c2d8d93188139c957e83ebcf59d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the symbol strobe source (internal or external)  <br /></td></tr>
<tr class="separator:ga138c2d8d93188139c957e83ebcf59d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae6ea2114ad54136694782ecf294056" id="r_ga4ae6ea2114ad54136694782ecf294056"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4ae6ea2114ad54136694782ecf294056">xorif_monitor_clear</a> (void)</td></tr>
<tr class="memdesc:ga4ae6ea2114ad54136694782ecf294056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all "monitor block" counters.  <br /></td></tr>
<tr class="separator:ga4ae6ea2114ad54136694782ecf294056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac99247934fc52772cc7f89a75b3f47bc" id="r_gac99247934fc52772cc7f89a75b3f47bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac99247934fc52772cc7f89a75b3f47bc">xorif_monitor_select</a> (uint8_t stream)</td></tr>
<tr class="memdesc:gac99247934fc52772cc7f89a75b3f47bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select stream to count with "monitor block".  <br /></td></tr>
<tr class="separator:gac99247934fc52772cc7f89a75b3f47bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5aa2137c5af236a8140996da0d3d4" id="r_ga23b5aa2137c5af236a8140996da0d3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga23b5aa2137c5af236a8140996da0d3d4">xorif_monitor_snapshot</a> (void)</td></tr>
<tr class="memdesc:ga23b5aa2137c5af236a8140996da0d3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take snapshot of the "monitor block" counters.  <br /></td></tr>
<tr class="separator:ga23b5aa2137c5af236a8140996da0d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6058ec85736dfc88d8c4927220f4775" id="r_gaf6058ec85736dfc88d8c4927220f4775"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6058ec85736dfc88d8c4927220f4775">xorif_monitor_read</a> (uint8_t counter, uint64_t *value)</td></tr>
<tr class="memdesc:gaf6058ec85736dfc88d8c4927220f4775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read specified counter from "monitor block".  <br /></td></tr>
<tr class="separator:gaf6058ec85736dfc88d8c4927220f4775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69bd2d45a44ac62f78813aafa319d1ec" id="r_ga69bd2d45a44ac62f78813aafa319d1ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga69bd2d45a44ac62f78813aafa319d1ec">xorif_stall_monitor_snapshot</a> (void)</td></tr>
<tr class="memdesc:ga69bd2d45a44ac62f78813aafa319d1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take snapshot of the "stall-monitor" flags.  <br /></td></tr>
<tr class="separator:ga69bd2d45a44ac62f78813aafa319d1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da69cc5cf78ec3fe41f9fccb68d9e2f" id="r_ga1da69cc5cf78ec3fe41f9fccb68d9e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1da69cc5cf78ec3fe41f9fccb68d9e2f">xorif_stall_monitor_read</a> (struct <a class="el" href="structxorif__stall__monitor.html">xorif_stall_monitor</a> *ptr)</td></tr>
<tr class="memdesc:ga1da69cc5cf78ec3fe41f9fccb68d9e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the "stall-monitor" flags.  <br /></td></tr>
<tr class="separator:ga1da69cc5cf78ec3fe41f9fccb68d9e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>"C" API for the Xilinx ORAN Channel Processor (libxocp) </p>
<p>"C" API for the Xilinx ORAN Radio Interface (libxorif)</p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf451ae0ea9768ba9266531c370a55c94" name="gaf451ae0ea9768ba9266531c370a55c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf451ae0ea9768ba9266531c370a55c94">&#9670;&#160;</a></span>xocp_error_codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaf451ae0ea9768ba9266531c370a55c94">xocp_error_codes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type for error/status codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a794b4b16c40fdc8eb8c60707dadfe29a" name="ggaf451ae0ea9768ba9266531c370a55c94a794b4b16c40fdc8eb8c60707dadfe29a"></a>XOCP_OPERATIONAL_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for operational errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a1df7c88f34e194938fa608f16590f7cc" name="ggaf451ae0ea9768ba9266531c370a55c94a1df7c88f34e194938fa608f16590f7cc"></a>XOCP_NULL_POINTER&#160;</td><td class="fielddoc"><p>Attempt to access memory with null pointer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a54e7ef62dc8a5d50c5e01b7cc6c6e6d4" name="ggaf451ae0ea9768ba9266531c370a55c94a54e7ef62dc8a5d50c5e01b7cc6c6e6d4"></a>XOCP_REGISTER_NOT_FOUND&#160;</td><td class="fielddoc"><p>Unknown register name. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94aafaefa566de3ba034b708009c3578be4" name="ggaf451ae0ea9768ba9266531c370a55c94aafaefa566de3ba034b708009c3578be4"></a>XOCP_MEMORY_ALLOCATION_FAIL&#160;</td><td class="fielddoc"><p>Memory allocation fail. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a00e01abfade942c7ae2bb8ce6971d84f" name="ggaf451ae0ea9768ba9266531c370a55c94a00e01abfade942c7ae2bb8ce6971d84f"></a>XOCP_TIMEOUT_FAIL&#160;</td><td class="fielddoc"><p>Timeout fail. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a663ede6ec196fa468f8ea6c1e7ab6060" name="ggaf451ae0ea9768ba9266531c370a55c94a663ede6ec196fa468f8ea6c1e7ab6060"></a>XOCP_CONFIGURATION_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for configuration errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a77e9e16463ab641c00a8912f37d5596b" name="ggaf451ae0ea9768ba9266531c370a55c94a77e9e16463ab641c00a8912f37d5596b"></a>XOCP_INVALID_CC&#160;</td><td class="fielddoc"><p>Component carrier instance is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a9e002468b6450125dcb7b47a3960d1e5" name="ggaf451ae0ea9768ba9266531c370a55c94a9e002468b6450125dcb7b47a3960d1e5"></a>XOCP_INVALID_RBS&#160;</td><td class="fielddoc"><p>Number of RBs is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94aa35b0cd782754b0a4dc838ab6662c6ff" name="ggaf451ae0ea9768ba9266531c370a55c94aa35b0cd782754b0a4dc838ab6662c6ff"></a>XOCP_INVALID_NUMEROLOGY&#160;</td><td class="fielddoc"><p>Numerology is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a4808c3d2a2edc65fb17c033c04b43f65" name="ggaf451ae0ea9768ba9266531c370a55c94a4808c3d2a2edc65fb17c033c04b43f65"></a>XOCP_INVALID_ANTENNAS&#160;</td><td class="fielddoc"><p>Antenna configuration is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94aaf8184e28652afc9cc695d2629de01ab" name="ggaf451ae0ea9768ba9266531c370a55c94aaf8184e28652afc9cc695d2629de01ab"></a>XOCP_SCHEDULING_ERROR&#160;</td><td class="fielddoc"><p>Error during scheduling. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94ae7a5dfbc6f6e1a032346b1ffdf322835" name="ggaf451ae0ea9768ba9266531c370a55c94ae7a5dfbc6f6e1a032346b1ffdf322835"></a>XOCP_FRAMEWORK_ERRORS&#160;</td><td class="fielddoc"><p>(Place holder for library / libmetal framework errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a3690197b67899b7b24d484544893c05c" name="ggaf451ae0ea9768ba9266531c370a55c94a3690197b67899b7b24d484544893c05c"></a>XOCP_LIBMETAL_ERROR&#160;</td><td class="fielddoc"><p>Error with libmetal framework. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a2d323c9201910db34f5e9f1acd3cc94a" name="ggaf451ae0ea9768ba9266531c370a55c94a2d323c9201910db34f5e9f1acd3cc94a"></a>XOCP_NO_SUCH_DEVICE&#160;</td><td class="fielddoc"><p>Requested device node does not exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94adffcd4c49097bfc116c8d60f3f1877de" name="ggaf451ae0ea9768ba9266531c370a55c94adffcd4c49097bfc116c8d60f3f1877de"></a>XOCP_NO_RESOURCES&#160;</td><td class="fielddoc"><p>Insufficient resources to complete request. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a7d343d91e5e2ef27617aa050b3a6f7f9" name="ggaf451ae0ea9768ba9266531c370a55c94a7d343d91e5e2ef27617aa050b3a6f7f9"></a>XOCP_INVALID_INSTANCE&#160;</td><td class="fielddoc"><p>Invalid device instance specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a7407194a50b20a599938ce060344e4bc" name="ggaf451ae0ea9768ba9266531c370a55c94a7407194a50b20a599938ce060344e4bc"></a>XOCP_INVALID_STATE&#160;</td><td class="fielddoc"><p>Incorrect state to handle request. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a9c8f4b684f5f945359e9d6688f04ac80" name="ggaf451ae0ea9768ba9266531c370a55c94a9c8f4b684f5f945359e9d6688f04ac80"></a>XOCP_OTHER_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for other errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94af1c7f4d1634f7a592b60d4537d24dc9f" name="ggaf451ae0ea9768ba9266531c370a55c94af1c7f4d1634f7a592b60d4537d24dc9f"></a>XOCP_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Generic "not-supported" error code. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94afc0ac5ea9864017911e7bbfc0c02569a" name="ggaf451ae0ea9768ba9266531c370a55c94afc0ac5ea9864017911e7bbfc0c02569a"></a>XOCP_INVALID_RESULT&#160;</td><td class="fielddoc"><p>Represents an invalid result. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a59302365415c9401277a5c89e2d717dc" name="ggaf451ae0ea9768ba9266531c370a55c94a59302365415c9401277a5c89e2d717dc"></a>XOCP_SUCCESS&#160;</td><td class="fielddoc"><p>Success! </p>
<p>No error! </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf451ae0ea9768ba9266531c370a55c94a3d2b0813042f04655882f64a9ee0c836" name="ggaf451ae0ea9768ba9266531c370a55c94a3d2b0813042f04655882f64a9ee0c836"></a>XOCP_FAILURE&#160;</td><td class="fielddoc"><p>Failure return code. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8be4e9d392425029993a9e8ad95b2be6" name="ga8be4e9d392425029993a9e8ad95b2be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8be4e9d392425029993a9e8ad95b2be6">&#9670;&#160;</a></span>xocp_events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga8be4e9d392425029993a9e8ad95b2be6">xocp_events</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerations for error/event information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8be4e9d392425029993a9e8ad95b2be6abc22c1565927dfec8392303c3003fddb" name="gga8be4e9d392425029993a9e8ad95b2be6abc22c1565927dfec8392303c3003fddb"></a>XOCP_DL_CC_UPDATE_TRIGGERED&#160;</td><td class="fielddoc"><p>Set when the DL CC update trigger has occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8be4e9d392425029993a9e8ad95b2be6af4389c5431a1c67bc749b798c0ed4c62" name="gga8be4e9d392425029993a9e8ad95b2be6af4389c5431a1c67bc749b798c0ed4c62"></a>XOCP_DL_SEQUENCE_ERROR&#160;</td><td class="fielddoc"><p>Set when the DL sequence has not completed in a symbol period. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8be4e9d392425029993a9e8ad95b2be6ad48ac96c5eb710be181edcbc4a72ddf5" name="gga8be4e9d392425029993a9e8ad95b2be6ad48ac96c5eb710be181edcbc4a72ddf5"></a>XOCP_DL_SEQUENCE_TABLE_ERROR&#160;</td><td class="fielddoc"><p>Set when DL data has been received when the sequence table is still updating. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8be4e9d392425029993a9e8ad95b2be6a28ee5450c2e063d6354e99a079ea20c7" name="gga8be4e9d392425029993a9e8ad95b2be6a28ee5450c2e063d6354e99a079ea20c7"></a>XOCP_UL_CC_UPDATE_TRIGGERED&#160;</td><td class="fielddoc"><p>Set when the UL CC update trigger has occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8be4e9d392425029993a9e8ad95b2be6a35aa4b4942ebdc467144a9242543c864" name="gga8be4e9d392425029993a9e8ad95b2be6a35aa4b4942ebdc467144a9242543c864"></a>XOCP_UL_SEQUENCE_ERROR&#160;</td><td class="fielddoc"><p>Set when the DL sequence has not completed in a symbol period. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8be4e9d392425029993a9e8ad95b2be6a2a824057e95d8053f1397fcf5f3b184c" name="gga8be4e9d392425029993a9e8ad95b2be6a2a824057e95d8053f1397fcf5f3b184c"></a>XOCP_UL_SEQUENCE_TABLE_ERROR&#160;</td><td class="fielddoc"><p>Set when DL data has been received when the sequence table is still updating. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad4565d94bfd9eeaa7959e4a06db49d0f" name="gad4565d94bfd9eeaa7959e4a06db49d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4565d94bfd9eeaa7959e4a06db49d0f">&#9670;&#160;</a></span>xocp_states</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gad4565d94bfd9eeaa7959e4a06db49d0f">xocp_states</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerations for state machine states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad4565d94bfd9eeaa7959e4a06db49d0fa02536e433de6b5137abf629c4c4b466f" name="ggad4565d94bfd9eeaa7959e4a06db49d0fa02536e433de6b5137abf629c4c4b466f"></a>XOCP_IDLE&#160;</td><td class="fielddoc"><p>Initial state (after libary loading) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4565d94bfd9eeaa7959e4a06db49d0faf97eab56e7f58517570b71a6541b5cdc" name="ggad4565d94bfd9eeaa7959e4a06db49d0faf97eab56e7f58517570b71a6541b5cdc"></a>XOCP_RESET&#160;</td><td class="fielddoc"><p>State after instance creation / reset (see <a class="el" href="#gaf6ffd8a57c5d7222b30ee1e27dad3160" title="Start a driver instance for the device.">xocp_start</a> / <a class="el" href="#ga2d34a3237dfd74eb86a302913c60de28" title="Puts the device and driver instance into reset.">xocp_reset</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4565d94bfd9eeaa7959e4a06db49d0fa36439db5df53566cf5730971b6ee1f42" name="ggad4565d94bfd9eeaa7959e4a06db49d0fa36439db5df53566cf5730971b6ee1f42"></a>XOCP_READY&#160;</td><td class="fielddoc"><p>State after releasing reset (see <a class="el" href="#ga2d34a3237dfd74eb86a302913c60de28" title="Puts the device and driver instance into reset.">xocp_reset</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4565d94bfd9eeaa7959e4a06db49d0fa94df60623c029d864ba346bb08980e64" name="ggad4565d94bfd9eeaa7959e4a06db49d0fa94df60623c029d864ba346bb08980e64"></a>XOCP_OPERATIONAL&#160;</td><td class="fielddoc"><p>State after activation (see <a class="el" href="#ga11cd61d97a8aa15b59980f476a157072" title="Activate the O-RAN Channel Processor operation.">xocp_activate</a>) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9a97d2a2455bd1b40ba42a84ddbe2f3f" name="ga9a97d2a2455bd1b40ba42a84ddbe2f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a97d2a2455bd1b40ba42a84ddbe2f3f">&#9670;&#160;</a></span>xorif_error_codes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9a97d2a2455bd1b40ba42a84ddbe2f3f">xorif_error_codes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type for error/status codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa25ee8ecd1294a4d25e52c3df60803a17" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa25ee8ecd1294a4d25e52c3df60803a17"></a>XORIF_OPERATIONAL_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for operational errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fab1d76613a67b8b15db924f08bd127e4c" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fab1d76613a67b8b15db924f08bd127e4c"></a>XORIF_NULL_POINTER&#160;</td><td class="fielddoc"><p>Attempt to access memory with null pointer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fac1b123cc4c3536879c23cb11921ed9d0" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fac1b123cc4c3536879c23cb11921ed9d0"></a>XORIF_REGISTER_NOT_FOUND&#160;</td><td class="fielddoc"><p>Unknown register name. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3faeda3aba2a8984c7eec1eefa7ff9c717b" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3faeda3aba2a8984c7eec1eefa7ff9c717b"></a>XORIF_MEMORY_ALLOCATION_FAIL&#160;</td><td class="fielddoc"><p>Memory allocation fail. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa078386ac24484cbf549961e7a793febc" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa078386ac24484cbf549961e7a793febc"></a>XORIF_TIMEOUT_FAIL&#160;</td><td class="fielddoc"><p>Timeout fail. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa2003ba5fea3e33e16b988ed0a86289d0" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa2003ba5fea3e33e16b988ed0a86289d0"></a>XORIF_CONFIGURATION_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for configuration errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3facda33b30a8f841b3fcbc3fe8c752eaa9" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3facda33b30a8f841b3fcbc3fe8c752eaa9"></a>XORIF_INVALID_CC&#160;</td><td class="fielddoc"><p>Component carrier instance is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa1a73cbf2d1f7292b849f9da3726a0313" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa1a73cbf2d1f7292b849f9da3726a0313"></a>XORIF_INVALID_SS&#160;</td><td class="fielddoc"><p>Spatial stream number is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa09ee5e8b650631ea5acb0d6aca182bd9" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa09ee5e8b650631ea5acb0d6aca182bd9"></a>XORIF_INVALID_RBS&#160;</td><td class="fielddoc"><p>Number of RBs is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa451fc990b012558a4b2d8028c781a7dd" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa451fc990b012558a4b2d8028c781a7dd"></a>XORIF_INVALID_CONFIG&#160;</td><td class="fielddoc"><p>Invalid configuration (general error) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa4f91e05f7c3f04097efd384ebe1355b0" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa4f91e05f7c3f04097efd384ebe1355b0"></a>XORIF_NUMEROLOGY_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Requested numerology is not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa5a2dddf89e5e2a94e6335821d3329384" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa5a2dddf89e5e2a94e6335821d3329384"></a>XORIF_COMP_MODE_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Requested compression mode is not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa1faea537523540ff11fc8bfe9223f320" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa1faea537523540ff11fc8bfe9223f320"></a>XORIF_FRONT_HAUL_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for Front-Haul specific errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa29e36b3ba768c321b68f719f3398a6ba" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa29e36b3ba768c321b68f719f3398a6ba"></a>XORIF_MAX_CTRL_SYM_EXCEEDED&#160;</td><td class="fielddoc"><p>Number of control symbols exceeds available space. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa08089c14b12e08ce6ce89c4837ba94b5" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa08089c14b12e08ce6ce89c4837ba94b5"></a>XORIF_MAX_DATA_SYM_EXCEEDED&#160;</td><td class="fielddoc"><p>Number of data symbols exceeds available space. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa3012c11d14676ad9fbee5dea0a63e590" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa3012c11d14676ad9fbee5dea0a63e590"></a>XORIF_BUFFER_SPACE_EXCEEDED&#160;</td><td class="fielddoc"><p>Required buffer space exceeds available space. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa5d8be60fc908dae826f288a33c72959f" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa5d8be60fc908dae826f288a33c72959f"></a>XORIF_INVALID_ETH_PORT&#160;</td><td class="fielddoc"><p>Invalid ethernet port number. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3faefb2e12b88492d80d7edab5897587ccc" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3faefb2e12b88492d80d7edab5897587ccc"></a>XORIF_INVALID_EAXC_ID&#160;</td><td class="fielddoc"><p>The specified eAxC ID is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa31de86d2f8e0f17527baa020a3daff49" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa31de86d2f8e0f17527baa020a3daff49"></a>XORIF_INVALID_RU_PORT_MAPPING&#160;</td><td class="fielddoc"><p>Invalid RU port mapping assignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa3bdbf375732f3687ee6924b71bcde20a" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa3bdbf375732f3687ee6924b71bcde20a"></a>XORIF_BEAMFORMER_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for Beamformer-specific errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa831f15721b2160abbf5cc4fe7c719e71" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa831f15721b2160abbf5cc4fe7c719e71"></a>XORIF_SCHEDULE_TABLE_EXCEEDED&#160;</td><td class="fielddoc"><p>Out of space in Beamformer schedule table. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa436e1c153c12de5c40bd47e116a17413" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa436e1c153c12de5c40bd47e116a17413"></a>XORIF_SCHEDULING_ERROR&#160;</td><td class="fielddoc"><p>Error during scheduling. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa8fdc834fd2e4fe38a2f8a9459d39c296" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa8fdc834fd2e4fe38a2f8a9459d39c296"></a>XORIF_INVALID_AG&#160;</td><td class="fielddoc"><p>Antenna group is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa2b213a6afb5f585bc912e78955668cee" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa2b213a6afb5f585bc912e78955668cee"></a>XORIF_INVALID_DFE&#160;</td><td class="fielddoc"><p>DFE instance is not valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa774af89ce327da0f5bb3dad6d0d8f048" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa774af89ce327da0f5bb3dad6d0d8f048"></a>XORIF_FRAMEWORK_ERRORS&#160;</td><td class="fielddoc"><p>(Place holder for library / libmetal framwork errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa4714fa10d010ea3a706076deba21addc" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa4714fa10d010ea3a706076deba21addc"></a>XORIF_LIBMETAL_ERROR&#160;</td><td class="fielddoc"><p>Error with libmetal framework. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa58d26412e9ade9963d87f109cc124392" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa58d26412e9ade9963d87f109cc124392"></a>XORIF_OTHER_ERRORS&#160;</td><td class="fielddoc"><p>(Place-holder for other errors) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fab68e276251beec0446da47d72b2f490a" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fab68e276251beec0446da47d72b2f490a"></a>XORIF_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Generic "not-supported" error code. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3faf431f4841dcd33bca7a22bf73f2e1376" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3faf431f4841dcd33bca7a22bf73f2e1376"></a>XORIF_INVALID_RESULT&#160;</td><td class="fielddoc"><p>Represents an invalid result. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa64437c7c5e97f4efece41f66478232d1" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa64437c7c5e97f4efece41f66478232d1"></a>XORIF_SUCCESS&#160;</td><td class="fielddoc"><p>Success! </p>
<p>No error! </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa9a03a40b03b36e83d8ebdc2a08ef6df4" name="gga9a97d2a2455bd1b40ba42a84ddbe2f3fa9a03a40b03b36e83d8ebdc2a08ef6df4"></a>XORIF_FAILURE&#160;</td><td class="fielddoc"><p>Failure return code. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9dd0d1e2b2202d805a2c6e0d4546e2ca" name="ga9dd0d1e2b2202d805a2c6e0d4546e2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd0d1e2b2202d805a2c6e0d4546e2ca">&#9670;&#160;</a></span>xorif_extra_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9dd0d1e2b2202d805a2c6e0d4546e2ca">xorif_extra_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type for extra capability bitmap flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9dd0d1e2b2202d805a2c6e0d4546e2caad39400a3bef1b3cc08ed40c9ac7af4f8" name="gga9dd0d1e2b2202d805a2c6e0d4546e2caad39400a3bef1b3cc08ed40c9ac7af4f8"></a>COMP_IN_CORE_ENABLED&#160;</td><td class="fielddoc"><p>Decompressor is available in core. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9dd0d1e2b2202d805a2c6e0d4546e2caa530bb779d3e1423698f2d0bb136ae922" name="gga9dd0d1e2b2202d805a2c6e0d4546e2caa530bb779d3e1423698f2d0bb136ae922"></a>PRECODING_EXT3_PORT&#160;</td><td class="fielddoc"><p>Compressor is available in core. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9dd0d1e2b2202d805a2c6e0d4546e2caa16e60e0e75e4a18f56fa3a056f1878e4" name="gga9dd0d1e2b2202d805a2c6e0d4546e2caa16e60e0e75e4a18f56fa3a056f1878e4"></a>OCP_IN_CORE&#160;</td><td class="fielddoc"><p>Precoding Extension 3 support is available in the core. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9dd0d1e2b2202d805a2c6e0d4546e2caa83a7f68f5ff430993ae34de98edfbdbb" name="gga9dd0d1e2b2202d805a2c6e0d4546e2caa83a7f68f5ff430993ae34de98edfbdbb"></a>COMP_32BIT_MODE_SUPPORT&#160;</td><td class="fielddoc"><p>Double Buffer PUxCH, PDxCH processing is available in core. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab913aef59d6dfeb48ca044dd311f80ba" name="gab913aef59d6dfeb48ca044dd311f80ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab913aef59d6dfeb48ca044dd311f80ba">&#9670;&#160;</a></span>xorif_fhi_alarms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gab913aef59d6dfeb48ca044dd311f80ba">xorif_fhi_alarms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerations for Front-Haul Interface alarm/status information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baafd8ffe789f75abadac9aefafb4e1d4ee" name="ggab913aef59d6dfeb48ca044dd311f80baafd8ffe789f75abadac9aefafb4e1d4ee"></a>FRAMER_RESET_STATUS&#160;</td><td class="fielddoc"><p>"Framer" reset status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baac016b81781957639286fb072a1774dcc" name="ggab913aef59d6dfeb48ca044dd311f80baac016b81781957639286fb072a1774dcc"></a>DEFRAMER_RESET_STATUS&#160;</td><td class="fielddoc"><p>"De-framer" reset status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baad0cc8a23001566871c8e28f655ee923e" name="ggab913aef59d6dfeb48ca044dd311f80baad0cc8a23001566871c8e28f655ee923e"></a>DEFRAMER_IN_FIFO_OF&#160;</td><td class="fielddoc"><p>"De-framer" input FIFO over-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baa04722b8a21db88031242714a56e84b19" name="ggab913aef59d6dfeb48ca044dd311f80baa04722b8a21db88031242714a56e84b19"></a>DEFRAMER_IN_FIFO_UF&#160;</td><td class="fielddoc"><p>"De-framer" input FIFO under-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baa48c541c16d67f948e2676d30d7b41508" name="ggab913aef59d6dfeb48ca044dd311f80baa48c541c16d67f948e2676d30d7b41508"></a>DEFRAMER_ETH_CIRC_BUFF_OF&#160;</td><td class="fielddoc"><p>"De-framer" Ethernet circular buffer over-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baa850c75064999b9990a3bfec10d50ce5c" name="ggab913aef59d6dfeb48ca044dd311f80baa850c75064999b9990a3bfec10d50ce5c"></a>DEFRAMER_ETH_CIRC_BUFF_PTR_OF&#160;</td><td class="fielddoc"><p>"De-framer" Ethernet circular buffer pointer over-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baaa82e656755b95d6d29e3bf4a99c18280" name="ggab913aef59d6dfeb48ca044dd311f80baaa82e656755b95d6d29e3bf4a99c18280"></a>FRAMER_OUT_FIFO_OF&#160;</td><td class="fielddoc"><p>"Framer" output FIFO over-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baa57c419410600e4aa01fff26f5dfebd36" name="ggab913aef59d6dfeb48ca044dd311f80baa57c419410600e4aa01fff26f5dfebd36"></a>FRAMER_OUT_FIFO_UF&#160;</td><td class="fielddoc"><p>"Framer" output FIFO under-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baaa61675bfc91f756829db3d59d09781bf" name="ggab913aef59d6dfeb48ca044dd311f80baaa61675bfc91f756829db3d59d09781bf"></a>FRAMER_PRACH_SECTION_OF&#160;</td><td class="fielddoc"><p>PRACH section over-flow. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baaa41d008ddcc6ae919186d8c5ec1d8458" name="ggab913aef59d6dfeb48ca044dd311f80baaa41d008ddcc6ae919186d8c5ec1d8458"></a>FRAMER_PRACH_SECTION_NF&#160;</td><td class="fielddoc"><p>PRACH section not-found. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baa5e6d55216d4daa07e4243dbcb33b8361" name="ggab913aef59d6dfeb48ca044dd311f80baa5e6d55216d4daa07e4243dbcb33b8361"></a>FRAMER_SECTION_OF&#160;</td><td class="fielddoc"><p>"Framer" section over-flow </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab913aef59d6dfeb48ca044dd311f80baa5a67c8e77f8a056ad5c3434345c5ab3a" name="ggab913aef59d6dfeb48ca044dd311f80baa5a67c8e77f8a056ad5c3434345c5ab3a"></a>AXI_TIMEOUT&#160;</td><td class="fielddoc"><p>AXI time-out. </p>
</td></tr>
</table>

</div>
</div>
<a id="gada146a3a3559be5ef31bf10fac14ff24" name="gada146a3a3559be5ef31bf10fac14ff24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada146a3a3559be5ef31bf10fac14ff24">&#9670;&#160;</a></span>xorif_ip_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gada146a3a3559be5ef31bf10fac14ff24">xorif_ip_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerations for supported Front-Haul Interface IP modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada146a3a3559be5ef31bf10fac14ff24a2637e615001e14c5b17fffb76774f0b9" name="ggada146a3a3559be5ef31bf10fac14ff24a2637e615001e14c5b17fffb76774f0b9"></a>IP_MODE_RAW&#160;</td><td class="fielddoc"><p>Raw. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada146a3a3559be5ef31bf10fac14ff24af87e096d037258dfd371fbfc34d3af79" name="ggada146a3a3559be5ef31bf10fac14ff24af87e096d037258dfd371fbfc34d3af79"></a>IP_MODE_IPV4&#160;</td><td class="fielddoc"><p>IPv4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada146a3a3559be5ef31bf10fac14ff24a8bde3d623e49b6310e35dfa4f098e6bb" name="ggada146a3a3559be5ef31bf10fac14ff24a8bde3d623e49b6310e35dfa4f098e6bb"></a>IP_MODE_IPV6&#160;</td><td class="fielddoc"><p>IPv6. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga26436fd9ffeac8fb09128b81b60f347b" name="ga26436fd9ffeac8fb09128b81b60f347b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26436fd9ffeac8fb09128b81b60f347b">&#9670;&#160;</a></span>xorif_iq_comp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type for IQ compression modes (ORAN values). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga26436fd9ffeac8fb09128b81b60f347ba51d9d0080c8e5d3e3b817eed725a6c84" name="gga26436fd9ffeac8fb09128b81b60f347ba51d9d0080c8e5d3e3b817eed725a6c84"></a>IQ_COMP_NONE&#160;</td><td class="fielddoc"><p>No compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga26436fd9ffeac8fb09128b81b60f347bad4753ac77b5aff45dc89f1f8e2559c26" name="gga26436fd9ffeac8fb09128b81b60f347bad4753ac77b5aff45dc89f1f8e2559c26"></a>IQ_COMP_BLOCK_FP&#160;</td><td class="fielddoc"><p>Block floating point compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga26436fd9ffeac8fb09128b81b60f347ba298523fae234039bd2d8cf2c79b45632" name="gga26436fd9ffeac8fb09128b81b60f347ba298523fae234039bd2d8cf2c79b45632"></a>IQ_COMP_BLOCK_SCALE&#160;</td><td class="fielddoc"><p>Block scaling compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga26436fd9ffeac8fb09128b81b60f347ba92efb1627370176f940e21b4c22007af" name="gga26436fd9ffeac8fb09128b81b60f347ba92efb1627370176f940e21b4c22007af"></a>IQ_COMP_U_LAW&#160;</td><td class="fielddoc"><p>U-Law compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga26436fd9ffeac8fb09128b81b60f347bad1f07bfe78168c2b76d38bddfe4269e5" name="gga26436fd9ffeac8fb09128b81b60f347bad1f07bfe78168c2b76d38bddfe4269e5"></a>IQ_COMP_MODULATION&#160;</td><td class="fielddoc"><p>Modulation compression. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac42ef3891485579391376bda5ac38175" name="gac42ef3891485579391376bda5ac38175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac42ef3891485579391376bda5ac38175">&#9670;&#160;</a></span>xorif_iq_comp_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gac42ef3891485579391376bda5ac38175">xorif_iq_comp_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type for supported IQ compression modes (bit-map). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac42ef3891485579391376bda5ac38175aeb5d9d01ac3e50861238e3a8ee824a00" name="ggac42ef3891485579391376bda5ac38175aeb5d9d01ac3e50861238e3a8ee824a00"></a>IQ_COMP_NONE_SUPPORT&#160;</td><td class="fielddoc"><p>No compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac42ef3891485579391376bda5ac38175ac85d0a5799f04376791f658b4e181493" name="ggac42ef3891485579391376bda5ac38175ac85d0a5799f04376791f658b4e181493"></a>IQ_COMP_BLOCK_FP_SUPPORT&#160;</td><td class="fielddoc"><p>Block floating point compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac42ef3891485579391376bda5ac38175aca4fb10dbe99a409d36eceb23db402bb" name="ggac42ef3891485579391376bda5ac38175aca4fb10dbe99a409d36eceb23db402bb"></a>IQ_COMP_BLOCK_SCALE_SUPPORT&#160;</td><td class="fielddoc"><p>Block scaling compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac42ef3891485579391376bda5ac38175a1fff0e2d81acb56d50e40373a6692bcf" name="ggac42ef3891485579391376bda5ac38175a1fff0e2d81acb56d50e40373a6692bcf"></a>IQ_COMP_U_LAW_SUPPORT&#160;</td><td class="fielddoc"><p>U-Law compression. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac42ef3891485579391376bda5ac38175a305e7eb21ae5b81f3362e05a4f065580" name="ggac42ef3891485579391376bda5ac38175a305e7eb21ae5b81f3362e05a4f065580"></a>IQ_COMP_MODULATION_SUPPORT&#160;</td><td class="fielddoc"><p>Modulation compression. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa337ebb1c5833b3836fc96fd24e25d06" name="gaa337ebb1c5833b3836fc96fd24e25d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa337ebb1c5833b3836fc96fd24e25d06">&#9670;&#160;</a></span>xorif_transport_protocol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa337ebb1c5833b3836fc96fd24e25d06">xorif_transport_protocol</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerations for supported Front-Haul Interface transport protocols. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa337ebb1c5833b3836fc96fd24e25d06a9bdc78e1b1bf6c3322342d1c7ae4388b" name="ggaa337ebb1c5833b3836fc96fd24e25d06a9bdc78e1b1bf6c3322342d1c7ae4388b"></a>PROTOCOL_ECPRI&#160;</td><td class="fielddoc"><p>eCPRI </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa337ebb1c5833b3836fc96fd24e25d06a6d3f3d36b1f8e6ca3dccc2946e648197" name="ggaa337ebb1c5833b3836fc96fd24e25d06a6d3f3d36b1f8e6ca3dccc2946e648197"></a>PROTOCOL_IEEE_1914_3&#160;</td><td class="fielddoc"><p>IEEE 1914.3. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga11cd61d97a8aa15b59980f476a157072" name="ga11cd61d97a8aa15b59980f476a157072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11cd61d97a8aa15b59980f476a157072">&#9670;&#160;</a></span>xocp_activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_activate </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate the O-RAN Channel Processor operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Transitions the SW to operational state. </dd></dl>

</div>
</div>
<a id="ga9614a06cd606c1f2a3deef32132dbead" name="ga9614a06cd606c1f2a3deef32132dbead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9614a06cd606c1f2a3deef32132dbead">&#9670;&#160;</a></span>xocp_clear_event_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_clear_event_status </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the current event status (e.g. </p>
<p>events/errors). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0f0dc0574e1f6fe358edba1145216309" name="ga0f0dc0574e1f6fe358edba1145216309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0dc0574e1f6fe358edba1145216309">&#9670;&#160;</a></span>xocp_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xocp_debug </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set debug/trace level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Debug level (0 = none, 1 = minimal, 2 = verbose) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cbda271a8bfaaa3c8a1a0858a0ce4aa" name="ga2cbda271a8bfaaa3c8a1a0858a0ce4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbda271a8bfaaa3c8a1a0858a0ce4aa">&#9670;&#160;</a></span>xocp_enable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_enable_interrupts </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable the event interrupts (according to supplied mask). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">mask</td><td>Bit-map mask for enabled interrupts (see <a class="el" href="#ga8be4e9d392425029993a9e8ad95b2be6" title="Enumerations for error/event information.">xocp_events</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaab4357f21c80d21ba991eee6fb5e0ecb" name="gaab4357f21c80d21ba991eee6fb5e0ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4357f21c80d21ba991eee6fb5e0ecb">&#9670;&#160;</a></span>xocp_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xocp_finish </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close/finalize the driver instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1032c0396e64c059895441bca7a00b8" name="gad1032c0396e64c059895441bca7a00b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1032c0396e64c059895441bca7a00b8">&#9670;&#160;</a></span>xocp_get_antenna_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_get_antenna_cfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxocp__antenna__data.html">xocp_antenna_data</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the antenna configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to write-back the antenna configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2f0a515e9398b7df6bb04e368295f398" name="ga2f0a515e9398b7df6bb04e368295f398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f0a515e9398b7df6bb04e368295f398">&#9670;&#160;</a></span>xocp_get_capabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_get_capabilities </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxocp__caps.html">xocp_caps</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device capabilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to write-back the capabilities (see <a class="el" href="structxocp__caps.html" title="Structure for supported capabilities.">xocp_caps</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae08ae7869a674d839707a4ab12723879" name="gae08ae7869a674d839707a4ab12723879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08ae7869a674d839707a4ab12723879">&#9670;&#160;</a></span>xocp_get_cc_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_get_cc_cfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxocp__cc__data.html">xocp_cc_data</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the component carrier configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">cc</td><td>Component carrier instance </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to write-back the component carrier configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2e857e841f5ba6d44aaae733cc75db8e" name="ga2e857e841f5ba6d44aaae733cc75db8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e857e841f5ba6d44aaae733cc75db8e">&#9670;&#160;</a></span>xocp_get_event_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_get_event_status </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current event status (e.g. </p>
<p>events/errors). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">status</td><td>Pointer to write-back the status (see <a class="el" href="#ga8be4e9d392425029993a9e8ad95b2be6" title="Enumerations for error/event information.">xocp_events</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga82472d6cb2902604c41880c81683f849" name="ga82472d6cb2902604c41880c81683f849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82472d6cb2902604c41880c81683f849">&#9670;&#160;</a></span>xocp_get_hw_internal_rev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xocp_get_hw_internal_rev </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal h/w revision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Internal revision </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa10e3b7f3ff3a4269243b2cc70c20701" name="gaa10e3b7f3ff3a4269243b2cc70c20701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa10e3b7f3ff3a4269243b2cc70c20701">&#9670;&#160;</a></span>xocp_get_hw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xocp_get_hw_version </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the h/w version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Version major = bits[24..31] minor = bits[16..23] revision = bits[8..15] </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf6109de427bcae994b7b4c42aef71782" name="gaf6109de427bcae994b7b4c42aef71782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6109de427bcae994b7b4c42aef71782">&#9670;&#160;</a></span>xocp_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_get_state </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>State (see <a class="el" href="#gad4565d94bfd9eeaa7959e4a06db49d0f" title="Enumerations for state machine states.">xocp_states</a>)</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga97785138a9cea8e247c6f412364d779c" name="ga97785138a9cea8e247c6f412364d779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97785138a9cea8e247c6f412364d779c">&#9670;&#160;</a></span>xocp_get_sw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xocp_get_sw_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the s/w version. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Version major = bits[24..31] minor = bits[16..23] revision = bits[8..15] patch = bits[0..7] </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabc9cd8da6a264e8107fb4af205caa5fd" name="gabc9cd8da6a264e8107fb4af205caa5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc9cd8da6a264e8107fb4af205caa5fd">&#9670;&#160;</a></span>xocp_get_trigger_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_get_trigger_cfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxocp__triggers.html">xocp_triggers</a> *</td>          <td class="paramname"><span class="paramname"><em>triggers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HW trigger configuration for DL/UL "update". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">triggers</td><td>Pointer to write-back the trigger configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga71441ce4e335da460f0044cac1eaaf34" name="ga71441ce4e335da460f0044cac1eaaf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71441ce4e335da460f0044cac1eaaf34">&#9670;&#160;</a></span>xocp_monitor_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_monitor_clear </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all "monitor block" counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad336b80523a9f214e2c026a68ec12bc1" name="gad336b80523a9f214e2c026a68ec12bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad336b80523a9f214e2c026a68ec12bc1">&#9670;&#160;</a></span>xocp_monitor_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_monitor_read </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>counter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read specified counter from "monitor block". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">counter</td><td>Counter to read (see TBD for details) </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to write back the counter value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaed2e5d420ec409de195f1be04a42ae4a" name="gaed2e5d420ec409de195f1be04a42ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed2e5d420ec409de195f1be04a42ae4a">&#9670;&#160;</a></span>xocp_monitor_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_monitor_snapshot </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take snapshot of the "monitor block" counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga26c079fad72f78f8d9e86d53c8af7925" name="ga26c079fad72f78f8d9e86d53c8af7925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c079fad72f78f8d9e86d53c8af7925">&#9670;&#160;</a></span>xocp_read_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_read_reg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read from a register / register field on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to write-back the read value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This utility function takes a C-string representation of the register name, e.g. "MODEL_PARAM". Alternatively, an offset value can be provided, e.g. "0x8". Ths API is intended primarily for debug/development and might not be available in the released library. </dd></dl>

</div>
</div>
<a id="gad69819662d0460ed5afb7b183a6fb2d3" name="gad69819662d0460ed5afb7b183a6fb2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69819662d0460ed5afb7b183a6fb2d3">&#9670;&#160;</a></span>xocp_read_reg_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_read_reg_offset </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read from a register / register field on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramname">offset</td><td>Offset value to be used with register </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to write-back the read value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="#ga26c079fad72f78f8d9e86d53c8af7925" title="Function to read from a register / register field on the device.">xocp_read_reg</a>. This function takes an additional offset, which is useful for indexing into a bank/block of registers. </dd></dl>

</div>
</div>
<a id="ga25120e04d622474f04345064c902d006" name="ga25120e04d622474f04345064c902d006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25120e04d622474f04345064c902d006">&#9670;&#160;</a></span>xocp_register_event_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_register_event_callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa2aee8cec3c52814f6b30da8f44871b0">xocp_isr_func_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a call-back function for event interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">callback</td><td>Function pointer for call-back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2d34a3237dfd74eb86a302913c60de28" name="ga2d34a3237dfd74eb86a302913c60de28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d34a3237dfd74eb86a302913c60de28">&#9670;&#160;</a></span>xocp_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the device and driver instance into reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">mode</td><td>Mode (0 = reset and release, 1 = hold in reset) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When the mode = 1, the module is held in the reset state. Call the function again with mode = 0 to release the reset and to reset normally. This can be useful when coordinating the reset with other devices / modules. Use mode = 0 to perform the reset immediately. </dd></dl>

</div>
</div>
<a id="ga5ee188ec91e4704e86f24d134f84ac61" name="ga5ee188ec91e4704e86f24d134f84ac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee188ec91e4704e86f24d134f84ac61">&#9670;&#160;</a></span>xocp_set_antenna_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_set_antenna_cfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structxocp__antenna__data.html">xocp_antenna_data</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the antenna configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the antenna configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga91cb69c970d87cb2de7a465935151a93" name="ga91cb69c970d87cb2de7a465935151a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91cb69c970d87cb2de7a465935151a93">&#9670;&#160;</a></span>xocp_set_cc_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_set_cc_cfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structxocp__cc__data.html">xocp_cc_data</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the component carrier configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">cc</td><td>Component carrier instance </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the component carrier configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf80a5ea55ae57b99cfcc26dde3a54a20" name="gaf80a5ea55ae57b99cfcc26dde3a54a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf80a5ea55ae57b99cfcc26dde3a54a20">&#9670;&#160;</a></span>xocp_set_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_set_schedule </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>sequence</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "next" symbol processing schedule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">mode</td><td>Mode (1 = DL, 2 = UL, 3 = both DL &amp; UL) </td></tr>
    <tr><td class="paramname">length</td><td>Length of sequence </td></tr>
    <tr><td class="paramname">sequence</td><td>Pointer to array defining the symbol sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The HW supports separate schedules for DL and UL. This API call can be used to program them separately (mode 1 or 2) or together (mode 3). The "sequence" parameter is an array (pointer) defining the sequence of component carrier symbols to process, e.g. {0, 0, 1} means a symbol from CC0, another symbol from CC0, and a symbol from CC1. The ordering of REs within a symbol is flexible in the HW, but the SW driver currently uses the following ordering [N/2 .. N-1, 0 .. N/2-1] where N is the total number of REs in the symbol (i.e. num_rbs * 12). Note, the component carrier IDs used here are the O-RAN CC IDs. Note, the actual symbol sequence needs to be coordinated with the DFE processing chain, and take into account the availability of symbols to/from the Front Haul Interface. This is left to the application SW. </dd></dl>

</div>
</div>
<a id="ga6faf33afeb951c812a95d195a5d1fbe5" name="ga6faf33afeb951c812a95d195a5d1fbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6faf33afeb951c812a95d195a5d1fbe5">&#9670;&#160;</a></span>xocp_set_trigger_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_set_trigger_cfg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structxocp__triggers.html">xocp_triggers</a> *</td>          <td class="paramname"><span class="paramname"><em>triggers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the HW trigger configuration for DL/UL "update". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">triggers</td><td>Pointer to the trigger configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf6ffd8a57c5d7222b30ee1e27dad3160" name="gaf6ffd8a57c5d7222b30ee1e27dad3160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ffd8a57c5d7222b30ee1e27dad3160">&#9670;&#160;</a></span>xocp_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_start </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a driver instance for the device. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Instance number (0..N)</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf6194042bff2a266ae3ebad7000cade4" name="gaf6194042bff2a266ae3ebad7000cade4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6194042bff2a266ae3ebad7000cade4">&#9670;&#160;</a></span>xocp_trigger_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_trigger_update </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the "update" HW trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function enables the "update" HW trigger. On the configured trigger event, the HW will update the "current" register configuration with the values programmed into the "next" registers. </dd></dl>

</div>
</div>
<a id="ga247c77c2b87ec6e01dbdfcb20c0716eb" name="ga247c77c2b87ec6e01dbdfcb20c0716eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga247c77c2b87ec6e01dbdfcb20c0716eb">&#9670;&#160;</a></span>xocp_write_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_write_reg </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write to a register / register field on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramname">value</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="#ga26c079fad72f78f8d9e86d53c8af7925" title="Function to read from a register / register field on the device.">xocp_read_reg</a>. </dd></dl>

</div>
</div>
<a id="ga272a85ffed433b3d5fc91f33dba6d961" name="ga272a85ffed433b3d5fc91f33dba6d961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272a85ffed433b3d5fc91f33dba6d961">&#9670;&#160;</a></span>xocp_write_reg_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xocp_write_reg_offset </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write to a register / register field on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Device instance ID (0..N) </td></tr>
    <tr><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramname">offset</td><td>Offset value to be used with register </td></tr>
    <tr><td class="paramname">value</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XOCP_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="#ga26c079fad72f78f8d9e86d53c8af7925" title="Function to read from a register / register field on the device.">xocp_read_reg</a>. This function takes an additional offset, which is useful for indexing into a bank/block of registers. </dd></dl>

</div>
</div>
<a id="ga5f12916f671ba6ee001f71f7f308e991" name="ga5f12916f671ba6ee001f71f7f308e991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f12916f671ba6ee001f71f7f308e991">&#9670;&#160;</a></span>xorif_clear_ru_ports_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_clear_ru_ports_table </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the RU ports mapping table. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This sets the whole mapping table to "all ones", which means type is set to "UNKNOWN" (i.e. not-used). </dd></dl>

</div>
</div>
<a id="ga60d073a6ce61f808a5489f61a721a41b" name="ga60d073a6ce61f808a5489f61a721a41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60d073a6ce61f808a5489f61a721a41b">&#9670;&#160;</a></span>xorif_configure_cc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_configure_cc </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga060c30abe081322ad6caeaaf99b0ef07" name="ga060c30abe081322ad6caeaaf99b0ef07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga060c30abe081322ad6caeaaf99b0ef07">&#9670;&#160;</a></span>xorif_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xorif_debug </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set debug level for the library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Debug level (0 = no debug, 1 = minimal, 2 = verbose) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e4aa0e1740018435969fe845e647a58" name="ga4e4aa0e1740018435969fe845e647a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e4aa0e1740018435969fe845e647a58">&#9670;&#160;</a></span>xorif_disable_cc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_disable_cc </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the specified component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7b3839531a2c838f6d1a0185d39efdb6" name="ga7b3839531a2c838f6d1a0185d39efdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b3839531a2c838f6d1a0185d39efdb6">&#9670;&#160;</a></span>xorif_enable_cc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_enable_cc </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the specified component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4eaaa1adb6e01922ff4576bd4e816a72" name="ga4eaaa1adb6e01922ff4576bd4e816a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eaaa1adb6e01922ff4576bd4e816a72">&#9670;&#160;</a></span>xorif_enable_fhi_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_enable_fhi_interrupts </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable Front-Haul Interface interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask (bit-map of interrupt sources) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The mask bits are the same as in the enum <a class="el" href="#gab913aef59d6dfeb48ca044dd311f80ba" title="Enumerations for Front-Haul Interface alarm/status information.">xorif_fhi_alarms</a>. </dd></dl>

</div>
</div>
<a id="ga83f699ac3378d0485e8dae26c60a0b79" name="ga83f699ac3378d0485e8dae26c60a0b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f699ac3378d0485e8dae26c60a0b79">&#9670;&#160;</a></span>xorif_get_capabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structxorif__caps.html">xorif_caps</a> * xorif_get_capabilities </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Front-Haul Interface capabilities. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Pointer to capabilities structure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5b5f8f7f67104640dc59f48e23e03bf0" name="ga5b5f8f7f67104640dc59f48e23e03bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5f8f7f67104640dc59f48e23e03bf0">&#9670;&#160;</a></span>xorif_get_cc_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_get_cc_config </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxorif__cc__config.html">xorif_cc_config</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configuration for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>Pointer to component carrier configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf94ca3eccdfae718818dd0cb1cd248e8" name="gaf94ca3eccdfae718818dd0cb1cd248e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94ca3eccdfae718818dd0cb1cd248e8">&#9670;&#160;</a></span>xorif_get_enabled_cc_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t xorif_get_enabled_cc_mask </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a bit-map of enabled component carriers. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Bit-map of the enabled component carriers </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>bit n == 0 means component carrier n disabled bit n == 1 means component carrier n enabled </dd></dl>

</div>
</div>
<a id="gaea741fbc93e935af409a051a4ab15e12" name="gaea741fbc93e935af409a051a4ab15e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea741fbc93e935af409a051a4ab15e12">&#9670;&#160;</a></span>xorif_get_fhi_alarms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xorif_get_fhi_alarms </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get alarms for Front-Haul Interface. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Bit-map of alarm status (see enum <a class="el" href="#gab913aef59d6dfeb48ca044dd311f80ba" title="Enumerations for Front-Haul Interface alarm/status information.">xorif_fhi_alarms</a>) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad09430b3cb4720a008415205497c3675" name="gad09430b3cb4720a008415205497c3675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad09430b3cb4720a008415205497c3675">&#9670;&#160;</a></span>xorif_get_fhi_cc_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_get_fhi_cc_alloc </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxorif__cc__alloc.html">xorif_cc_alloc</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the configured allocation for the specified component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>Pointer to component carrier allocation structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is mainly for debug / testing. </dd></dl>

</div>
</div>
<a id="ga1a6fd499b68bfb88d4d3b8d61182ce74" name="ga1a6fd499b68bfb88d4d3b8d61182ce74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a6fd499b68bfb88d4d3b8d61182ce74">&#9670;&#160;</a></span>xorif_get_fhi_eth_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_get_fhi_eth_stats </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxorif__fhi__eth__stats.html">xorif_fhi_eth_stats</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Front-Haul Interface Ethernet statistics for the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Ethernet port </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>Pointer to component statistics data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2358c0211954f64b207879fe43e0e5bb" name="ga2358c0211954f64b207879fe43e0e5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2358c0211954f64b207879fe43e0e5bb">&#9670;&#160;</a></span>xorif_get_fhi_hw_internal_rev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xorif_get_fhi_hw_internal_rev </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Front-Haul Interface h/w internal revision number. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Internal revision </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga325b96c5f53b0bdfb57f535035ffbe8d" name="ga325b96c5f53b0bdfb57f535035ffbe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga325b96c5f53b0bdfb57f535035ffbe8d">&#9670;&#160;</a></span>xorif_get_fhi_hw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xorif_get_fhi_hw_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Front-Haul Interface h/w version. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Version (major = bits[24..31], minor = bits[16..23], version = bits[0..15]) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac3c1601fb0d91568c305ecf8fdf87811" name="gac3c1601fb0d91568c305ecf8fdf87811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3c1601fb0d91568c305ecf8fdf87811">&#9670;&#160;</a></span>xorif_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_get_state </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state of the library. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 = not operational</li>
<li>1 = operational </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac5031b867d3c6588655036dabd56fa05" name="gac5031b867d3c6588655036dabd56fa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5031b867d3c6588655036dabd56fa05">&#9670;&#160;</a></span>xorif_get_sw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t xorif_get_sw_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the s/w version. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Version (major = bits[24..31], minor = bits[16..23], version = bits[0..15]) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga354bba5bbf86cb1a6ea346e47590cb5b" name="ga354bba5bbf86cb1a6ea346e47590cb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354bba5bbf86cb1a6ea346e47590cb5b">&#9670;&#160;</a></span>xorif_has_front_haul_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_has_front_haul_interface </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is a O-RAN makeFront-Haul Interface in the system. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 = false (no)</li>
<li>1 = true (yes) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0c512ca218a568fdbeffacd599bfbf27" name="ga0c512ca218a568fdbeffacd599bfbf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c512ca218a568fdbeffacd599bfbf27">&#9670;&#160;</a></span>xorif_has_oran_channel_processor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_has_oran_channel_processor </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is a O-RAN Channel Processor in the system. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 = false (no)</li>
<li>1 = true (yes) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9d3a3d79d4361a962e11f28fefaafc36" name="ga9d3a3d79d4361a962e11f28fefaafc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d3a3d79d4361a962e11f28fefaafc36">&#9670;&#160;</a></span>xorif_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_init </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>device_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the API s/w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device_name</td><td>Device name of the Front-Haul Interface (leave as NULL for automatic) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the device_name is left as NULL, then the library will search the devices for the most appropriate one. Specify the exact device name if you want to override this behavior. </dd></dl>

</div>
</div>
<a id="ga4ae6ea2114ad54136694782ecf294056" name="ga4ae6ea2114ad54136694782ecf294056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae6ea2114ad54136694782ecf294056">&#9670;&#160;</a></span>xorif_monitor_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_monitor_clear </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all "monitor block" counters. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf6058ec85736dfc88d8c4927220f4775" name="gaf6058ec85736dfc88d8c4927220f4775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6058ec85736dfc88d8c4927220f4775">&#9670;&#160;</a></span>xorif_monitor_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_monitor_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>counter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read specified counter from "monitor block". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>Counter to read (see PG370 for details) </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to write back the counter value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac99247934fc52772cc7f89a75b3f47bc" name="gac99247934fc52772cc7f89a75b3f47bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac99247934fc52772cc7f89a75b3f47bc">&#9670;&#160;</a></span>xorif_monitor_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_monitor_select </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select stream to count with "monitor block". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga23b5aa2137c5af236a8140996da0d3d4" name="ga23b5aa2137c5af236a8140996da0d3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b5aa2137c5af236a8140996da0d3d4">&#9670;&#160;</a></span>xorif_monitor_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_monitor_snapshot </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take snapshot of the "monitor block" counters. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#gaf6058ec85736dfc88d8c4927220f4775" title="Read specified counter from &quot;monitor block&quot;.">xorif_monitor_read</a> to read the counters after taking the snapshot. </dd></dl>

</div>
</div>
<a id="ga83f0df0585606c4660e267b34ecd2077" name="ga83f0df0585606c4660e267b34ecd2077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f0df0585606c4660e267b34ecd2077">&#9670;&#160;</a></span>xorif_read_fhi_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_read_fhi_reg </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to read a field from the Front-Haul Interface register map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>Pointer to write back the read value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadc0dd7c8f1d053aa5b62bbdc53366bc2" name="gadc0dd7c8f1d053aa5b62bbdc53366bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc0dd7c8f1d053aa5b62bbdc53366bc2">&#9670;&#160;</a></span>xorif_read_fhi_reg_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_read_fhi_reg_offset </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to read a field from the Front-Haul Interface register map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset to be used with register (useful for repeated register banks) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>Pointer to write back the read value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga20531a711869b69d9015727d99047531" name="ga20531a711869b69d9015727d99047531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20531a711869b69d9015727d99047531">&#9670;&#160;</a></span>xorif_register_fhi_isr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_register_fhi_isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8faee7bbc7441a5fcbfa86e44a838fcf">isr_func_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a call-back function for Front-Haul Interface alarm interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function pointer for call-back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When an alarm interrupt occurs, the interrupt handler calls the call-back function (if it exists) and then performs default handling to log the error and clear the alarm. The call-back function should be short. </dd></dl>

</div>
</div>
<a id="ga33241710e1a63e9329a0bbd7fb7b3039" name="ga33241710e1a63e9329a0bbd7fb7b3039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33241710e1a63e9329a0bbd7fb7b3039">&#9670;&#160;</a></span>xorif_reset_fhi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_reset_fhi </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the Front-Haul Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Reset mode (0 = immediate, 1 = hold in reset) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When the mode = 1, the module is held in the reset state. Call the function again with mode = 0 to release the reset and to reset normally. This can be useful when coordinating the reset with other devices / modules. Use mode = 0 to perform the reset immediately. The reset operation should always succeed. </dd></dl>

</div>
</div>
<a id="ga9760fd53b96007a0c917a22c1f4a73d6" name="ga9760fd53b96007a0c917a22c1f4a73d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9760fd53b96007a0c917a22c1f4a73d6">&#9670;&#160;</a></span>xorif_set_cc_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_config </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structxorif__cc__config.html">xorif_cc_config</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the configuration for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa069ac48f7c01a52c0c28d83b1153d95" name="gaa069ac48f7c01a52c0c28d83b1153d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa069ac48f7c01a52c0c28d83b1153d95">&#9670;&#160;</a></span>xorif_set_cc_dl_iq_compression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_dl_iq_compression </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bit_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a></td>          <td class="paramname"><span class="paramname"><em>comp_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mplane</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the downlink IQ compression for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>Bit width (0-16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_method</td><td>Compression method (see <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b" title="Enumerated type for IQ compression modes (ORAN values).">xorif_iq_comp</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mplane</td><td>Flag indicating M-plane (1) or C-plane (0) configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For alignment with O-RAN standard, a bit_width value of 0 is equivalent to 16. The 'mplane' indicates M-plane (static) or C-plane (dynamic) configuration. With static configuration, the M-plane is used to configure the compression mode using the supplied values (bit_width and comp_method). With dynamic configuration, the C-plane is used to configure the compression. However, the supplied values (bit_width and comp_method) are still used for internal buffer sizing. </dd></dl>

</div>
</div>
<a id="gade9e7a76564f554192277acd1852e3ad" name="gade9e7a76564f554192277acd1852e3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9e7a76564f554192277acd1852e3ad">&#9670;&#160;</a></span>xorif_set_cc_dl_iq_compression_per_ss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_dl_iq_compression_per_ss </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ss</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bit_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a></td>          <td class="paramname"><span class="paramname"><em>comp_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the downlink IQ compression per spatial stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ss</td><td>The base spatial stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>Bit width (0-16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_method</td><td>Compression method (see <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b" title="Enumerated type for IQ compression modes (ORAN values).">xorif_iq_comp</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Flag indicating whether to enable (1) or disable (0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>The number of spatial streams in this assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For alignment with O-RAN standard, a bit_width value of 0 is equivalent to 16. This special feature can be used to provide per-spatial stream decompression. This over-rides any per-component carrier static (i.e. M-Plane) decompression configuration. However, dynamic configuration has highest priority if enabled. Summary: per-cc dynamic &gt; per-ss static &gt; per-cc static The API allows N streams to be configured to the same values (number=N), or only a single stream (number=1). The API can be used to enable/disable the per-spatial stream configuration. The sizing of buffers is always based on the component carrier configuration. </dd></dl>

</div>
</div>
<a id="gaebaccf31445eb3da67493984f26e3fba" name="gaebaccf31445eb3da67493984f26e3fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebaccf31445eb3da67493984f26e3fba">&#9670;&#160;</a></span>xorif_set_cc_dl_sections_per_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_dl_sections_per_symbol </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_sect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_ctrl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the number of sections and ctrl words per downlink symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_sect</td><td>Maximum number of sections per symbol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_ctrl</td><td>Maximum number of control words per symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The num_sect and num_ctrl values are used in determining buffer sizes. The num_ctrl value can vary depending on the Section Type, for example 1 control word for Type 1, 2 words for Type 0 or Type 3, N words for Type 11, etc. See PG370 for details. </dd></dl>

</div>
</div>
<a id="gaf43336d896069b72003f112aae1f396d" name="gaf43336d896069b72003f112aae1f396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43336d896069b72003f112aae1f396d">&#9670;&#160;</a></span>xorif_set_cc_dl_timing_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_dl_timing_parameters </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delay_comp_cp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delay_comp_up</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>advance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the downlink timing parameters for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_comp_cp</td><td>Delay compensation for C-Plane (in microseconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_comp_up</td><td>Delay compensation for U-Plane (in microseconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">advance</td><td>Control time advance (in microseconds) (i.e. TCP_ADV_DL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See PG370 for details. The delay_comp_cp value is the size of the valid reception window for C-Plane packets, and is equivalent to (i.e. T2A_MAX_CP_DL - T2A_MIN_CP_DL). The delay_comp_up value is the size of the valid reception window for U-Plane packets, and is equivalent to (i.e. T2A_MAX_UP - T2A_MIN_UP). The advance value is equivalent to TCP_ADV_DL. </dd></dl>

</div>
</div>
<a id="ga891c7e0622f34429e09023f7d64e54d0" name="ga891c7e0622f34429e09023f7d64e54d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga891c7e0622f34429e09023f7d64e54d0">&#9670;&#160;</a></span>xorif_set_cc_frames_per_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_frames_per_symbol </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_frames</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the number of Ethernet frames per downlink symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_frames</td><td>Maximum number of Ethernet frames per symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The num_frames value is used in determining buffer sizes. See PG370 for details. </dd></dl>

</div>
</div>
<a id="ga58c4dcf40c1bac85c7ff288b02b443f3" name="ga58c4dcf40c1bac85c7ff288b02b443f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58c4dcf40c1bac85c7ff288b02b443f3">&#9670;&#160;</a></span>xorif_set_cc_frames_per_symbol_ssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_frames_per_symbol_ssb </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_frames</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the number of Ethernet frames allowed per SSB symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_frames</td><td>Maximum number of Ethernet frames per symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The num_frames value is used in determining buffer sizes. See PG370 for details. </dd></dl>

</div>
</div>
<a id="ga29a935e45b74a6ed2766f286a6bc21d3" name="ga29a935e45b74a6ed2766f286a6bc21d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29a935e45b74a6ed2766f286a6bc21d3">&#9670;&#160;</a></span>xorif_set_cc_iq_compression_prach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_iq_compression_prach </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bit_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a></td>          <td class="paramname"><span class="paramname"><em>comp_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mplane</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the PRACH compression for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>Bit width (0-16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_method</td><td>Compression method (see <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b" title="Enumerated type for IQ compression modes (ORAN values).">xorif_iq_comp</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mplane</td><td>Flag indicating M-plane (1) or C-plane (0) configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For alignment with O-RAN standard, a bit_width value of 0 is equivalent to 16. The 'mplane' indicates M-plane (static) or C-plane (dynamic) configuration. With static configuration, the M-plane is used to configure the compression mode using the supplied values (bit_width and comp_method). With dynamic configuration, the C-plane is used to configure the compression. However, the supplied values (bit_width and comp_method) are still used for internal buffer sizing. </dd></dl>

</div>
</div>
<a id="gaedc9a1a8a947162d98100ab2e92171da" name="gaedc9a1a8a947162d98100ab2e92171da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc9a1a8a947162d98100ab2e92171da">&#9670;&#160;</a></span>xorif_set_cc_iq_compression_ssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_iq_compression_ssb </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bit_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a></td>          <td class="paramname"><span class="paramname"><em>comp_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mplane</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the SSB compression for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>Bit width (0-16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_method</td><td>Compression method (see <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b" title="Enumerated type for IQ compression modes (ORAN values).">xorif_iq_comp</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mplane</td><td>Flag indicating M-plane (1) or C-plane (0) configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For alignment with O-RAN standard, a bit_width value of 0 is equivalent to 16. The 'mplane' indicates M-plane (static) or C-plane (dynamic) configuration. With static configuration, the M-plane is used to configure the compression mode using the supplied values (bit_width and comp_method). With dynamic configuration, the C-plane is used to configure the compression. However, the supplied values (bit_width and comp_method) are still used for internal buffer sizing. </dd></dl>

</div>
</div>
<a id="gac5bb9cbc4aae17d9db299f7a7595efa0" name="gac5bb9cbc4aae17d9db299f7a7595efa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5bb9cbc4aae17d9db299f7a7595efa0">&#9670;&#160;</a></span>xorif_set_cc_num_rbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_num_rbs </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_rbs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of RBs for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_rbs</td><td>Number of RBs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9fd1067dc7af1a96676441b93b0b8bb0" name="ga9fd1067dc7af1a96676441b93b0b8bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fd1067dc7af1a96676441b93b0b8bb0">&#9670;&#160;</a></span>xorif_set_cc_num_rbs_ssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_num_rbs_ssb </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_rbs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of RBs for the component carrier' SSB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_rbs</td><td>Number of RBs (see note) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The only valid values of num_rbs are 0 (no SSB) and 20 (standard SSB). </dd></dl>

</div>
</div>
<a id="ga4a3da356c6483228f09c42c2f5e2136e" name="ga4a3da356c6483228f09c42c2f5e2136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3da356c6483228f09c42c2f5e2136e">&#9670;&#160;</a></span>xorif_set_cc_numerology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_numerology </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>numerology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>extended_cp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the numerology for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numerology</td><td>Numerology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extended_cp</td><td>Extended CP mode (0 = no, 1 = yes) (numerology 2 only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac3373c25f26f3e81c2cd24f22f1ff807" name="gac3373c25f26f3e81c2cd24f22f1ff807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3373c25f26f3e81c2cd24f22f1ff807">&#9670;&#160;</a></span>xorif_set_cc_numerology_ssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_numerology_ssb </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>numerology</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>extended_cp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the numerology for the component carrier's SSB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numerology</td><td>Numerology </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extended_cp</td><td>Extended CP mode (0 = no, 1 = yes) (numerology 2 only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga13b800f4ca34e642e206e29a2abb6c6a" name="ga13b800f4ca34e642e206e29a2abb6c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13b800f4ca34e642e206e29a2abb6c6a">&#9670;&#160;</a></span>xorif_set_cc_sections_per_symbol_ssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_sections_per_symbol_ssb </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_sect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_ctrl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the number of sections and ctrl words per SSB symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_sect</td><td>Maximum number of sections per symbol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_ctrl</td><td>Maximum number of control words per symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The num_sect and num_ctrl values are used in determining buffer sizes. The num_ctrl value can vary depending on the Section Type, for example 1 control word for Type 1, 2 words for Type 0 or Type 3, N words for Type 11, etc. See PG370 for details. </dd></dl>

</div>
</div>
<a id="gaa3201eb51ec95a208a12a952da12fa26" name="gaa3201eb51ec95a208a12a952da12fa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3201eb51ec95a208a12a952da12fa26">&#9670;&#160;</a></span>xorif_set_cc_time_advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_time_advance </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>deskew</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>advance_ul</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>advance_dl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum deskew and control advance timing for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deskew</td><td>Maximum deskew time (in microseconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">advance_ul</td><td>Control advance in uplink (in microseconds) (c.f. T2A_MIN_CP_UL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">advance_dl</td><td>Control advance in downlink (in microseconds) (c.f. TCP_ADV_DL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See PG370 for details. Note: This function is deprecated. Use <a class="el" href="#gaf9fc75de00d2748b74ca7662e9ff5c5e" title="Set the uplink timing parameters for the component carrier.">xorif_set_cc_ul_timing_parameters()</a> and <a class="el" href="#gaf43336d896069b72003f112aae1f396d" title="Set the downlink timing parameters for the component carrier.">xorif_set_cc_dl_timing_parameters()</a>. </dd></dl>

</div>
</div>
<a id="ga5ae73ee046a29f31dcaec51ea42c674e" name="ga5ae73ee046a29f31dcaec51ea42c674e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ae73ee046a29f31dcaec51ea42c674e">&#9670;&#160;</a></span>xorif_set_cc_ul_iq_compression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_ul_iq_compression </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bit_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b">xorif_iq_comp</a></td>          <td class="paramname"><span class="paramname"><em>comp_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mplane</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the uplink IQ compression for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>Bit width (0-16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_method</td><td>Compression method (see <a class="el" href="#ga26436fd9ffeac8fb09128b81b60f347b" title="Enumerated type for IQ compression modes (ORAN values).">xorif_iq_comp</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mplane</td><td>Flag indicating M-plane (1) or C-plane (0) configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For alignment with O-RAN standard, a bit_width value of 0 is equivalent to 16. The 'mplane' indicates M-plane (static) or C-plane (dynamic) configuration. With static configuration, the M-plane is used to configure the compression mode using the supplied values (bit_width and comp_method). With dynamic configuration, the C-plane is used to configure the compression. However, the supplied values (bit_width and comp_method) are still used for internal buffer sizing. </dd></dl>

</div>
</div>
<a id="ga8791772c6c278a79420538c9b0df202d" name="ga8791772c6c278a79420538c9b0df202d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8791772c6c278a79420538c9b0df202d">&#9670;&#160;</a></span>xorif_set_cc_ul_sections_per_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_ul_sections_per_symbol </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_sect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_ctrl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the number of sections and ctrl words per uplink symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_sect</td><td>Maximum number of sections per symbol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_ctrl</td><td>Maximum number of control words per symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The num_sect and num_ctrl values are used in determining buffer sizes. The num_ctrl value can vary depending on the Section Type, for example 1 control word for Type 1, 2 words for Type 0 or Type 3, N words for Type 11, etc. See PG370 for details. </dd></dl>

</div>
</div>
<a id="gaf9fc75de00d2748b74ca7662e9ff5c5e" name="gaf9fc75de00d2748b74ca7662e9ff5c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9fc75de00d2748b74ca7662e9ff5c5e">&#9670;&#160;</a></span>xorif_set_cc_ul_timing_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_cc_ul_timing_parameters </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delay_comp_cp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>advance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radio_ch_delay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the uplink timing parameters for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_comp_cp</td><td>Delay compensation for C-Plane (in microseconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">advance</td><td>Control time advance (in microseconds) (i.e. T2A_MIN_CP_UL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radio_ch_delay</td><td>Total delay from output of FH to "air" (in microseconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See PG370 for details. The delay_comp_cp value is the size of the valid reception window for C-Plane packets, and is equivalent to (i.e. T2A_MAX_CP_UL - T2A_MIN_CP_UL). The advance value is equivalent to T2A_MIN_CP_UL. The radio_ch_delay value defines the time offset between the 10ms strobe and the actual "air" strobe; it compensates for the system delay for beam- former, DFE, etc. </dd></dl>

</div>
</div>
<a id="ga5ade05b06d847a6a4487dbd7f27ac315" name="ga5ade05b06d847a6a4487dbd7f27ac315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ade05b06d847a6a4487dbd7f27ac315">&#9670;&#160;</a></span>xorif_set_fhi_dest_mac_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_dest_mac_addr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the destination ethernet MAC address for the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Ethernet port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>MAC address (6 byte array) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga550a91743d3aa995cc2c3c550d3afd72" name="ga550a91743d3aa995cc2c3c550d3afd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550a91743d3aa995cc2c3c550d3afd72">&#9670;&#160;</a></span>xorif_set_fhi_eaxc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_eaxc_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>du_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bs_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ru_bits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the eAxC ID (c.f. </p>
<p>ecpriRtcid and ecpriPcid) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">du_bits</td><td>DU ID length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bs_bits</td><td>BS ID length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cc_bits</td><td>CC ID length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ru_bits</td><td>RU ID length (in bits) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The eAxC ID is 16 bits, and the total length of the 4 fields should equal 16. RU port ids are mapped by one of 2 methods: mask or table. For mask-based mapping see <a class="el" href="#ga857309ea8ff7506568e3111761877eb8" title="Set the RU port ID bits.">xorif_set_ru_ports</a> &amp; <a class="el" href="#ga9379066763d5ba7f1c7aa95467a2b69c" title="Set the RU port ID bits (alternative API, including LTE).">xorif_set_ru_ports_lte</a> For table-based mapping see <a class="el" href="#ga02e5936a62ac2c0a803c96adcc735fb7" title="Set the RU port table mapping mode.">xorif_set_ru_ports_table_mode</a> and <a class="el" href="#ga6fc3068a93476321d8449fcc7871a29f" title="Assign one or more RU port id mappings.">xorif_set_ru_ports_table</a> </dd></dl>

</div>
</div>
<a id="gac40979657aa87123b4cc380182829cde" name="gac40979657aa87123b4cc380182829cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac40979657aa87123b4cc380182829cde">&#9670;&#160;</a></span>xorif_set_fhi_packet_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_packet_filter </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>[4]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the packet filter for the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Ethernet port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>Pointer to an array of 16 x 32-bit words </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Pointer to an array of 4 x 16-bit words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The packet filter is defined by 4 filter words each 128-bits (16 bytes) wide. In the IP core's register map, each filter word is arranged as 4 x 32-bit words. Each filter word has an associated mask register which indicates whether a specific byte of the filter is used or not (if bit[X] = 0 then byte[X] of the filter word is used; if bit[x] = 1 then byte[x] of the filter word is not used). (See pg370-oran-radio-if document for full details). </dd></dl>

</div>
</div>
<a id="gaa3e5758db6df0d589c86337d9268278d" name="gaa3e5758db6df0d589c86337d9268278d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3e5758db6df0d589c86337d9268278d">&#9670;&#160;</a></span>xorif_set_fhi_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_protocol </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#gaa337ebb1c5833b3836fc96fd24e25d06">xorif_transport_protocol</a></td>          <td class="paramname"><span class="paramname"><em>transport</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>vlan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#gada146a3a3559be5ef31bf10fac14ff24">xorif_ip_mode</a></td>          <td class="paramname"><span class="paramname"><em>ip_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the protocol, vlan and IP mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transport</td><td>Transport protocol (eCPRI, IEEE 1914.3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan</td><td>VLAN tagging mode (0 = no VLAN, 1 = add VLAN tag) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_mode</td><td>IP mode (Raw, IPv4, IPv6) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In addition to configuring the protocol, this function also configures the packet filters for all the Ethernet ports. The default filter configuration is very basic, and just configures the filter for the transport protocol (eCPRI or IEEE 1914.3) and VLAN tagging. Use the <a class="el" href="#gac40979657aa87123b4cc380182829cde" title="Set the packet filter for the specified port.">xorif_set_fhi_packet_filter</a> function for more precise control of the filter configuration. Use <a class="el" href="#ga0f9924458bf10f080b305ec9e8f7858e" title="Set the protocol, vlan and IP mode.">xorif_set_fhi_protocol_alt</a> to set the protocol without affecting the packet filter configuration. </dd></dl>

</div>
</div>
<a id="ga0f9924458bf10f080b305ec9e8f7858e" name="ga0f9924458bf10f080b305ec9e8f7858e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f9924458bf10f080b305ec9e8f7858e">&#9670;&#160;</a></span>xorif_set_fhi_protocol_alt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_protocol_alt </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#gaa337ebb1c5833b3836fc96fd24e25d06">xorif_transport_protocol</a></td>          <td class="paramname"><span class="paramname"><em>transport</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>vlan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#gada146a3a3559be5ef31bf10fac14ff24">xorif_ip_mode</a></td>          <td class="paramname"><span class="paramname"><em>ip_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the protocol, vlan and IP mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transport</td><td>Transport protocol (eCPRI, IEEE 1914.3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan</td><td>VLAN tagging mode (0 = no VLAN, 1 = add VLAN tag) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_mode</td><td>IP mode (Raw, IPv4, IPv6) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function just sets the protocol, without affecting the packet filter configuration (c.f. <a class="el" href="#gaa3e5758db6df0d589c86337d9268278d" title="Set the protocol, vlan and IP mode.">xorif_set_fhi_protocol</a>). </dd></dl>

</div>
</div>
<a id="gab5e2fed6728de86a1a1f9d8d1880ff0d" name="gab5e2fed6728de86a1a1f9d8d1880ff0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e2fed6728de86a1a1f9d8d1880ff0d">&#9670;&#160;</a></span>xorif_set_fhi_src_mac_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_src_mac_addr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the source ethernet MAC address for the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Ethernet port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>MAC address (6 byte array) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga39e46206326f26259890154207ba55d4" name="ga39e46206326f26259890154207ba55d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39e46206326f26259890154207ba55d4">&#9670;&#160;</a></span>xorif_set_fhi_vlan_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_fhi_vlan_tag </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>dei</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>pcp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the VLAN tag for the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Ethernet port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dei</td><td>VLAN DEI </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcp</td><td>VLAN PCP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga38ffe1b4e867ecfce419bd59bb6c12b6" name="ga38ffe1b4e867ecfce419bd59bb6c12b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ffe1b4e867ecfce419bd59bb6c12b6">&#9670;&#160;</a></span>xorif_set_modu_dest_mac_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_modu_dest_mac_addr </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>du</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>dei</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>pcp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the multi-O-DU MAC address / VLAN tag mapping for DU port address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">du</td><td>O-DU port address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>MAC address (6 byte array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dei</td><td>VLAN DEI </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcp</td><td>VLAN PCP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API allows different destination MAC addresses and VLAN IDs to be assigned by DU port address. This applies for uplink packets only. If VLAN is not required, then the relevant fields (id, dei, pcp) should be set to 0. The configuration is applied to all Ethernet ports. </dd></dl>

</div>
</div>
<a id="gac12c71caeba9b52a930a9b4848471f58" name="gac12c71caeba9b52a930a9b4848471f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12c71caeba9b52a930a9b4848471f58">&#9670;&#160;</a></span>xorif_set_modu_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_modu_mode </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>enable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable the multi-O-DU MAC address / VLAN tag mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>(0 = disable, 1 = enable) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API enables/disables the O-DU MAC address (and VLAN tag) mapping for multi-O-DU support. When this is disabled, the MAC address and VLAN tag are set by <a class="el" href="#ga5ade05b06d847a6a4487dbd7f27ac315" title="Set the destination ethernet MAC address for the specified port.">xorif_set_fhi_dest_mac_addr</a> and <a class="el" href="#ga39e46206326f26259890154207ba55d4" title="Set the VLAN tag for the specified port.">xorif_set_fhi_vlan_tag</a> API calls. When this is enabled, the MAC address and VLAN tag can be set by <a class="el" href="#ga38ffe1b4e867ecfce419bd59bb6c12b6" title="Set the multi-O-DU MAC address / VLAN tag mapping for DU port address.">xorif_set_modu_dest_mac_addr</a> for different DU port address. </dd></dl>

</div>
</div>
<a id="gadece8f9464fdb7b1056a4f45bd313dfe" name="gadece8f9464fdb7b1056a4f45bd313dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadece8f9464fdb7b1056a4f45bd313dfe">&#9670;&#160;</a></span>xorif_set_mtu_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_mtu_size </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the uplink MTU size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of MTU </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API programs the HW to use a value less than was configured in the IP GUI (which is the value shown in the config_xran_fram_eth_pkt_max register). This can be used to force the HW to generate smaller packets. However, its use is not recommended as it results in non optimal traffic with extra framing overhead. Allowed MTU size: 1 &gt;= size &gt;= config_xran_fram_eth_pkt_max. </dd></dl>

</div>
</div>
<a id="ga857309ea8ff7506568e3111761877eb8" name="ga857309ea8ff7506568e3111761877eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857309ea8ff7506568e3111761877eb8">&#9670;&#160;</a></span>xorif_set_ru_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ru_ports </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ru_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ss_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>user_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>prach_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ssb_val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RU port ID bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ru_bits</td><td>RU ID length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ss_bits</td><td>Spatial stream length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask used when testing for user/PRACH/SSB value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_val</td><td>User ID value (identifies regular U-plane spatial streams) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prach_val</td><td>PRACH ID value (identifies PRACH spatial streams) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ssb_val</td><td>SSB ID value (identifies SSB spatial streams) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>RU port ids are mapped by one of 2 methods: mask or table. This API relates to mask-based RU port mapping. The number of RU bits is set by <a class="el" href="#ga550a91743d3aa995cc2c3c550d3afd72" title="Set the eAxC ID (c.f.">xorif_set_fhi_eaxc_id</a>. The present function defines additional masks/values which are used to split the RU ports into user/PRACH/SSB/... spatial streams. The ru_bits define the total size of the RU ID field; the ss_bits define the number of LSBs that are used the specify the spatial stream ID; the remaining MSBs (ru_bits - ss_bits) define a mask which identifies the spatial stream as user/PRACH/SSB/etc. For example, if mask is 0xC0 and ssb_val is 0x80, then if the (ID &amp; 0xC0) == 0x80 then the ID relates to SSB spatial streams. ID mapping can be easily disabled for a particular stream, by simply setting the "val" to be greater than "mask". For example, if mask is 0xC0, then setting ssb_val to 0xFFFF causes SSB ID mapping to be disabled. </dd></dl>

</div>
</div>
<a id="ga9379066763d5ba7f1c7aa95467a2b69c" name="ga9379066763d5ba7f1c7aa95467a2b69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9379066763d5ba7f1c7aa95467a2b69c">&#9670;&#160;</a></span>xorif_set_ru_ports_lte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ru_ports_lte </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ru_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ss_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>user_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>prach_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ssb_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>lte_val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RU port ID bits (alternative API, including LTE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ru_bits</td><td>RU ID length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ss_bits</td><td>Spatial stream length (in bits) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask used when testing for user/PRACH/SSB value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_val</td><td>User ID value (identifies regular U-plane spatial streams) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prach_val</td><td>PRACH ID value (identifies PRACH spatial streams) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ssb_val</td><td>SSB ID value (identifies SSB spatial streams) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lte_val</td><td>LTE ID value (identifies LTE spatial streams) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>RU port ids are mapped by one of 2 methods: mask or table. This API relates to mask-based RU port mapping. The number of RU bits is set by <a class="el" href="#ga550a91743d3aa995cc2c3c550d3afd72" title="Set the eAxC ID (c.f.">xorif_set_fhi_eaxc_id</a>. The present function defines additional masks/values which are used to split the RU ports into user/PRACH/SSB/... spatial streams. This function is an alternative to <a class="el" href="#ga857309ea8ff7506568e3111761877eb8" title="Set the RU port ID bits.">xorif_set_ru_ports</a>, which also provides mapping for LTE spatial streams. </dd></dl>

</div>
</div>
<a id="ga6fc3068a93476321d8449fcc7871a29f" name="ga6fc3068a93476321d8449fcc7871a29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc3068a93476321d8449fcc7871a29f">&#9670;&#160;</a></span>xorif_set_ru_ports_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ru_ports_table </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign one or more RU port id mappings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The base (external) address to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The base (internal) port to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The port type (see note for values) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>The number of port mappings in this assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>RU port ids are mapped by one of 2 methods: mask or table. This API relates to table-based RU port mapping. The "address" depends upon the mode (see <a class="el" href="#ga02e5936a62ac2c0a803c96adcc735fb7" title="Set the RU port table mapping mode.">xorif_set_ru_ports_table_mode</a>). The "port" is the internal port number to use. The "type" indicates which port group to use:<ul>
<li>0 = PDXCH</li>
<li>1 = PUXCH</li>
<li>2 = SSB</li>
<li>3 = PRACH</li>
<li>4 - LTE</li>
<li>5..62 = user-defined</li>
<li>63 = UNKNOWN (uses to indicate not-used) The "number" indicates the number of mappings in the assignment. When number &gt; 1, the address and port values are incremented for each mapping. For example, address 0 -&gt; port 8, address 1 -&gt; port 9, address 2 -&gt; port 10, etc. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga02e5936a62ac2c0a803c96adcc735fb7" name="ga02e5936a62ac2c0a803c96adcc735fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02e5936a62ac2c0a803c96adcc735fb7">&#9670;&#160;</a></span>xorif_set_ru_ports_table_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ru_ports_table_mode </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>sub_mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RU port table mapping mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>RU port id table mapping mode (see notes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_mode</td><td>RU port id table mapping sub-mode (see notes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>RU port ids are mapped by one of 2 methods: mask or table. This API relates to table-based RU port mapping. The "mode" and "sub-mode" allows flexibility in how addresses are mapped to ports. See PG370 for further details, of modes, sub-modes, and address construction. </dd></dl>

</div>
</div>
<a id="ga0c351b7236674c869768299e67127b1f" name="ga0c351b7236674c869768299e67127b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c351b7236674c869768299e67127b1f">&#9670;&#160;</a></span>xorif_set_ru_ports_table_vcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ru_ports_table_vcc </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>ccid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign one or more RU port id mappings (alternative with "Virtual CCID"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The base (external) address to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The base (internal) port to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The port type (see note for values) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccid</td><td>The "virtual" CC ID (see note for values) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>The number of port mappings in this assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>RU port ids are mapped by one of 2 methods: mask or table. This API relates to table-based RU port mapping, specifically for "mode 2" operation, which uses concept of "Virtual CCID" (see PG370). "Mode 2" supports BS/CC sharing, and requires mapping of "real" CC ID (i.e. as understood by O-DU) to the "virtual" CC ID (i.e. the CC instance in the s/w driver). The "address" depends upon the mode (see <a class="el" href="#ga02e5936a62ac2c0a803c96adcc735fb7" title="Set the RU port table mapping mode.">xorif_set_ru_ports_table_mode</a>). The "port" is the internal port number to use. The "type" indicates which port group to use:<ul>
<li>0 = PDXCH</li>
<li>1 = PUXCH</li>
<li>2 = SSB</li>
<li>3 = PRACH</li>
<li>4 - LTE</li>
<li>5..62 = user-defined</li>
<li>63 = UNKNOWN (uses to indicate not-used) The "ccid" is the "virtual" CC ID (i.e. the CC instance in the s/w driver). The "number" indicates the number of mappings in the assignment. When number &gt; 1, the address and port values are incremented for each mapping. For example, address 0 -&gt; port 8, address 1 -&gt; port 9, address 2 -&gt; port 10, etc. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga138c2d8d93188139c957e83ebcf59d70" name="ga138c2d8d93188139c957e83ebcf59d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138c2d8d93188139c957e83ebcf59d70">&#9670;&#160;</a></span>xorif_set_symbol_strobe_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_symbol_strobe_source </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the symbol strobe source (internal or external) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source (0 = internally generated, 1 = externally generated) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5c35a9fac66256693c3a76f7cfc654c1" name="ga5c35a9fac66256693c3a76f7cfc654c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c35a9fac66256693c3a76f7cfc654c1">&#9670;&#160;</a></span>xorif_set_system_constants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_system_constants </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structxorif__system__constants.html">xorif_system_constants</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set system "constants". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Point to system constants structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>These are system "constants" and should be set prior to configuring carriers. </dd></dl>

</div>
</div>
<a id="ga2b1fa8a5ab92c334994a32f2d83e65fd" name="ga2b1fa8a5ab92c334994a32f2d83e65fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b1fa8a5ab92c334994a32f2d83e65fd">&#9670;&#160;</a></span>xorif_set_ul_bid_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ul_bid_forward </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the uplink beam-id forward time for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Uplink beam-id forward time (in microseconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure. See PG370 for details. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4f5ebd79d6d83c0d6e37eff6cb7465d9" name="ga4f5ebd79d6d83c0d6e37eff6cb7465d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5ebd79d6d83c0d6e37eff6cb7465d9">&#9670;&#160;</a></span>xorif_set_ul_radio_ch_dly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_set_ul_radio_ch_dly </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the uplink radio channel delay estimate for the component carrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Component carrier to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>Delay estimate (in microseconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure. See PG370 for details. Note: This function is deprecated. Use <a class="el" href="#gaf9fc75de00d2748b74ca7662e9ff5c5e" title="Set the uplink timing parameters for the component carrier.">xorif_set_cc_ul_timing_parameters()</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1da69cc5cf78ec3fe41f9fccb68d9e2f" name="ga1da69cc5cf78ec3fe41f9fccb68d9e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da69cc5cf78ec3fe41f9fccb68d9e2f">&#9670;&#160;</a></span>xorif_stall_monitor_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_stall_monitor_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxorif__stall__monitor.html">xorif_stall_monitor</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the "stall-monitor" flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to structure to write-back the flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "stall-monitor" flags are diagnostic aids. There are "stall" flags for up to 20 downlink spatial streams, 16 uplink spatial streams, 4 PRACH spatial streams, 4 SSB spatial streams and 4 "unsolicited" spatial streams. The flags are refreshed every 10ms, and remain high if a packet for that spatial stream was not received within that 10ms window. See PG370 for further details. </dd></dl>

</div>
</div>
<a id="ga69bd2d45a44ac62f78813aafa319d1ec" name="ga69bd2d45a44ac62f78813aafa319d1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69bd2d45a44ac62f78813aafa319d1ec">&#9670;&#160;</a></span>xorif_stall_monitor_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_stall_monitor_snapshot </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take snapshot of the "stall-monitor" flags. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#ga1da69cc5cf78ec3fe41f9fccb68d9e2f" title="Read the &quot;stall-monitor&quot; flags.">xorif_stall_monitor_read</a> to read the flags after taking the snapshot. </dd></dl>

</div>
</div>
<a id="gac5c6289aa4a4970e2e6c2244d876b20b" name="gac5c6289aa4a4970e2e6c2244d876b20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c6289aa4a4970e2e6c2244d876b20b">&#9670;&#160;</a></span>xorif_write_fhi_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_write_fhi_reg </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to write a field to the Front-Haul Interface register map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write to the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga58421571a3f2bf166aeb91fcdfdaa036" name="ga58421571a3f2bf166aeb91fcdfdaa036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58421571a3f2bf166aeb91fcdfdaa036">&#9670;&#160;</a></span>xorif_write_fhi_reg_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xorif_write_fhi_reg_offset </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to write a field to the Front-Haul Interface register map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Register field name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset to be used with register (useful for repeated register banks) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write to the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XORIF_SUCCESS on success</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2022 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
